<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<!--
 * Copyright (c) 2009-2021 NVIDIA CORPORATION.  All rights reserved.
 *
 * NVIDIA Corporation and its licensors retain all intellectual property
 * and proprietary rights in and to this software, related documentation
 * and any modifications thereto.  Any use, reproduction, disclosure or
 * distribution of this software and related documentation without an express
 * license agreement from NVIDIA Corporation is strictly prohibited.
-->
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NVIDIA DRIVE OS Linux SDK API Reference: IPC APIs | NVIDIA Docs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="reverb-search.js"></script>
<script src="//assets.adobedtm.com/5d4962a43b79/c1061d2c5e7b/launch-191c2462b890.min.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="nv_theme_dark.css" rel="stylesheet" type="text/css"/>
<style>
    body {
        background-position: 350px 200px;
        background-image: url(watermark.png);
        background-repeat: no-repeat;
        background-attachment: fixed;
    }
    @media (min-width: 320px) and (max-width: 480px) {
        body { background-position: 55px 350px; }
    }
    @media (min-width: 768px) and (max-width: 1024px) {
        body { background-position: 55px 200px; }
    }
    @media (min-width: 768px) and (max-width: 1024px) and (orientation: landscape) {
        body { background-position: 55px 200px; }
    }
</style>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tbody>
    <tr>
      <td>
      <div>
            <a id="nv-logo" href="https://www.nvidia.com/"></a>
        </div>
        <!--img src="./NVLogo_2D_H.jpg" width="110" height="44"-->
      </td>
    </tr>
    <tr id="titlearea" valign="middle">
        <td width="40%">
            <h1 style="margin-left:12px; margin-top: 10px; margin-bottom:12px;">NVIDIA DRIVE OS Linux SDK API Reference</h1>
        </td>
        <td>
            <h5 style="text-align:right; margin-top: 10px; margin-bottom:12px;">
                6.0.5 Release
            </h5>
        </td>
    </tr>
  </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__nvsci__ipc__api.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">IPC APIs<div class="ingroups"><a class="el" href="group__nvsci__top.html">Software Communication Interfaces</a> &raquo; <a class="el" href="group__nvsci__group__ipc.html">Inter-Process Communication</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The NvSciIpc library provides interfaces for any two entities in a system to communicate with each other irrespective of where they are placed. Entities can be in:</p><ul>
<li>Different threads in the same process</li>
<li>The same process</li>
<li>Different processes in the same VM</li>
<li>Different VMs on the same SoC</li>
</ul>
<p>Each of these different boundaries will be abstracted by a library providing unified communication (Read/Write) APIs to entities. The communication consists of two bi-directional send/receive queues.</p>
<p>When Init operation group APIs are used, the user should call them in the following order, with or without <a class="el" href="structNvSciEventService.html" title="An abstract interface for a program&#39;s event handling infrastructure.">NvSciEventService</a>.</p>
<p><b> Typical call flow with NvSciIpc library </b></p>
<p>1) Init mode</p><ul>
<li><a class="el" href="group__nvsci__ipc__api.html#ga9d1e5e9447b89ea626616fdf7d2dbe91" title="Initializes the NvSciIpc library.">NvSciIpcInit()</a></li>
<li><a class="el" href="group__nvsci__ipc__api.html#ga3acc28ad8a4ebe4d8175c70324424094" title="Opens an endpoint with the given name.">NvSciIpcOpenEndpoint()</a></li>
<li>Set event reporting path NvSciIpcSetQnxPulseParam() (QNX OS-specific) or <a class="el" href="group__nvsci__ipc__api.html#ga17c8f735886735c578222acb63761abf" title="Returns the NvSciIpc file descriptor for a given endpoint.">NvSciIpcGetLinuxEventFd()</a> (Linux OS-specific)</li>
<li><a class="el" href="group__nvsci__ipc__api.html#ga962dca348abb1e7066709464f19cbc35" title="Returns endpoint information.">NvSciIpcGetEndpointInfo()</a></li>
<li><a class="el" href="group__nvsci__ipc__api.html#ga93831442d2f06ef6ec4787bf6ec76c7c" title="Resets an endpoint.">NvSciIpcResetEndpointSafe()</a></li>
<li>Ensure a channel is established <div class="fragment"><div class="line">loop {</div>
<div class="line">    <a class="code" href="group__nvsci__ipc__api.html#gac0c8482abc29cc356f0c73ed0cca1bd4">NvSciIpcGetEvent</a>()</div>
<div class="line">    if (event &amp; <a class="code" href="group__nvsci__ipc__api.html#ga10730765f6c4abaaf38e147f7087e029">NV_SCI_IPC_EVENT_CONN_EST_ALL</a>) break</div>
<div class="line">    else {</div>
<div class="line">        NvSciIpcWaitEventQnx() (QNX OS-specific) or</div>
<div class="line">        select(), epoll() (Linux OS-specific)</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --></li>
</ul>
<p>2) Runtime mode (loop)</p><ul>
<li><a class="el" href="group__nvsci__ipc__api.html#gac0c8482abc29cc356f0c73ed0cca1bd4" title="Get Events.">NvSciIpcGetEvent()</a></li>
<li>If an event is not desired, call OS-blocking API NvSciIpcWaitEventQnx() (QNX OS-specific) or select(), epoll() (Linux OS-specific)</li>
<li><a class="el" href="group__nvsci__ipc__api.html#ga63bb5b3fe6f72bb793043cac78af60fd" title="Returns the contents of the next frame from an endpoint.">NvSciIpcReadSafe()</a> or <a class="el" href="group__nvsci__ipc__api.html#ga2eb7f4a5c6e33a641b980ed9c3612cf1" title="Writes a new frame to the endpoint.">NvSciIpcWriteSafe()</a></li>
</ul>
<p>3) De-Init mode</p><ul>
<li><a class="el" href="group__nvsci__ipc__api.html#gab5bef8557494be3e426950bf49ba24dd" title="Closes an endpoint with the given handle (safety version)">NvSciIpcCloseEndpointSafe()</a></li>
<li><a class="el" href="group__nvsci__ipc__api.html#gabc2132de8f3f32e62e7a297f67e8da9d" title="De-initializes the NvSciIpc library.">NvSciIpcDeinit()</a></li>
</ul>
<p><b> Typical call flow with NvSciIpc and <a class="el" href="structNvSciEventService.html" title="An abstract interface for a program&#39;s event handling infrastructure.">NvSciEventService</a> library </b></p>
<p><a class="el" href="structNvSciEventService.html" title="An abstract interface for a program&#39;s event handling infrastructure.">NvSciEventService</a> provides APIs that replace OS-specific event-blocking API. They are only compatible with an endpoint which is opened with NvSciOpenEndpointWithEventService().</p>
<p>1) Init mode</p><ul>
<li><a class="el" href="group__nvsci__ipc__event.html#ga9d4082ed65f56a8fc0dcc9f628816818" title="Creates a new event loop service.">NvSciEventLoopServiceCreateSafe()</a> to get eventLoopService</li>
<li><a class="el" href="group__nvsci__ipc__api.html#ga9d1e5e9447b89ea626616fdf7d2dbe91" title="Initializes the NvSciIpc library.">NvSciIpcInit()</a></li>
<li><a class="el" href="group__nvsci__ipc__api.html#gaa1386ae6969f2b8d52e8eaacb248d6ae" title="Opens an endpoint with the given name and event service.">NvSciIpcOpenEndpointWithEventService()</a></li>
<li><a class="el" href="group__nvsci__ipc__api.html#ga75c70be08614ce8d81526edf3cdaeefa" title="Get NvSciIpc event notifier.">NvSciIpcGetEventNotifier()</a> to get eventNotifier</li>
<li><a class="el" href="group__nvsci__ipc__api.html#ga962dca348abb1e7066709464f19cbc35" title="Returns endpoint information.">NvSciIpcGetEndpointInfo()</a></li>
<li><a class="el" href="group__nvsci__ipc__api.html#ga93831442d2f06ef6ec4787bf6ec76c7c" title="Resets an endpoint.">NvSciIpcResetEndpointSafe()</a></li>
<li>Ensure a channel is established <div class="fragment"><div class="line">loop {</div>
<div class="line">    <a class="code" href="group__nvsci__ipc__api.html#gac0c8482abc29cc356f0c73ed0cca1bd4">NvSciIpcGetEvent</a>()</div>
<div class="line">    if (event &amp; <a class="code" href="group__nvsci__ipc__api.html#ga10730765f6c4abaaf38e147f7087e029">NV_SCI_IPC_EVENT_CONN_EST_ALL</a>) break</div>
<div class="line">    else {</div>
<div class="line">        eventLoopService-&gt;WaitForEvent(eventNotifier)</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --></li>
</ul>
<p>2) Runtime mode (loop)</p><ul>
<li><a class="el" href="group__nvsci__ipc__api.html#gac0c8482abc29cc356f0c73ed0cca1bd4" title="Get Events.">NvSciIpcGetEvent()</a></li>
<li>If an event is not desired,</li>
<li>eventLoopService-&gt;WaitForEvent()</li>
<li><a class="el" href="group__nvsci__ipc__api.html#ga63bb5b3fe6f72bb793043cac78af60fd" title="Returns the contents of the next frame from an endpoint.">NvSciIpcReadSafe()</a> or <a class="el" href="group__nvsci__ipc__api.html#ga2eb7f4a5c6e33a641b980ed9c3612cf1" title="Writes a new frame to the endpoint.">NvSciIpcWriteSafe()</a></li>
</ul>
<p>3) De-Init mode</p><ul>
<li>eventNotifier-&gt;Delete()</li>
<li><a class="el" href="group__nvsci__ipc__api.html#gab5bef8557494be3e426950bf49ba24dd" title="Closes an endpoint with the given handle (safety version)">NvSciIpcCloseEndpointSafe()</a></li>
<li><a class="el" href="group__nvsci__ipc__api.html#gabc2132de8f3f32e62e7a297f67e8da9d" title="De-initializes the NvSciIpc library.">NvSciIpcDeinit()</a></li>
<li>eventLoopService-&gt;EventService.Delete()</li>
</ul>
<p><b>Using multi-threading in NvSciIpc - QNX OS</b></p>
<p>For Inter-VM and Inter-Process backend applications on QNX OS, only a single event-blocking OS API (i.e. NvSciIpcWaitEventQnx(), <a class="el" href="structNvSciEventLoopService.html#aec8fc738a7a9af6460f9f31d72d4ced7" title="Waits up to a configurable timeout for a particular event notification, servicing events with configu...">NvSciEventLoopService::WaitForEvent()</a>) is allowed per endpoint in the same process boundary. If a client application tries to use receiving and sending thread separately for the same endpoint handle, the event-blocking OS APIs must be used in a single thread in order to receive remote notification. Once a remote notification arrives in the thread, the notification should be forwarded to the other thread using the same endpoint handle through any OS synchronization method (e.g. sem_post, pthread_cond_signal or MsgSendPulse etc.) Single thread usage is recommended to handle both TX and RX data.</p>
<p><b>Configuring thread pool of resource manager - QNX OS</b></p>
<p>NvSciIpc resource manager (io-nvsciipc) and IVC resource manager (devv-nvivc) use thread pool to manage concurrent request from multiple NvSciIpc client processes using NvSciIpc library. io-nvsciipc is used during opening endpoint and devv-nvivc is used for Inter-VM IVC signaling. Drive OS users should evaluate thread pool capacity of io-nvsciipc and devv-nvivc then configure them with -t option in startup script. Thread pool capacity for NvSciIPC can be evaluated based on number of parallel outstanding NvSciIPC requests, at any point of time, that are expected in the system. Default value of thread pool capacity is 10.</p>
<p><b>Getting events before using Read/Write NvSciIpc API</b></p>
<p>Before using any Read/Write APIs, the user must check if <a class="el" href="group__nvsci__ipc__api.html#gaf4436046ffdc9524d53e2591de04f0fa">NV_SCI_IPC_EVENT_READ</a> or <a class="el" href="group__nvsci__ipc__api.html#gae7b1528d3c4eb51df15de78422632fa4">NV_SCI_IPC_EVENT_WRITE</a> event is available through <a class="el" href="group__nvsci__ipc__api.html#gac0c8482abc29cc356f0c73ed0cca1bd4" title="Get Events.">NvSciIpcGetEvent()</a>. <a class="el" href="group__nvsci__ipc__api.html#gac0c8482abc29cc356f0c73ed0cca1bd4" title="Get Events.">NvSciIpcGetEvent()</a> has additional support to establish connection between two endpoint software entities.</p>
<p><b>When to use blocking API</b></p>
<p>Users of NvSciIpc must call OS event-blocking API to wait for an event when <a class="el" href="group__nvsci__ipc__api.html#gac0c8482abc29cc356f0c73ed0cca1bd4" title="Get Events.">NvSciIpcGetEvent()</a> does not return desired events. The following are OS event-blocking API examples:</p><ul>
<li>QNX : NvSciIpcWaitEventQnx()</li>
<li>LINUX: select(), epoll() etc.</li>
<li><a class="el" href="structNvSciEventService.html" title="An abstract interface for a program&#39;s event handling infrastructure.">NvSciEventService</a>: <a class="el" href="structNvSciEventLoopService.html#aec8fc738a7a9af6460f9f31d72d4ced7" title="Waits up to a configurable timeout for a particular event notification, servicing events with configu...">NvSciEventLoopService::WaitForEvent()</a>,<br  />
 <a class="el" href="structNvSciEventLoopService.html#a2455650b85b83010a1e6d3fc93af2277" title="Waits up to a configurable timeout for any of a set of particular event notifications,...">NvSciEventLoopService::WaitForMultipleEvents()</a></li>
</ul>
<p>If user process needs to wait for events from multiple remote NvSciIpc endpoint processes, use single blocking call from single thread instead of using blocking call per endpoint thread. This is recommended to improve performance by avoiding thread creation per endpoint. <a class="el" href="structNvSciEventLoopService.html#a2455650b85b83010a1e6d3fc93af2277" title="Waits up to a configurable timeout for any of a set of particular event notifications,...">NvSciEventLoopService::WaitForMultipleEvents()</a> blocking call is suitable for this use case.</p>
<p><b>How to check if peer endpoint entity receives a message</b></p>
<p>NvSciIpc library does not provide information about whether a peer endpoint entity receives all sent messages from a local endpoint entity. If such a mechanism is required, the client user should implement separate message acknowledgment in the application layer.</p>
<p><b>Checksum for data integrity</b></p>
<p>NvSciIpc does not provide checksum for data to be transferred or check for data integrity error. If such a mechanism is required, the client user should implement checksum processing routine for data.</p>
<p><b>Recommended Read/Write APIs</b></p>
<p>Using <a class="el" href="group__nvsci__ipc__api.html#ga63bb5b3fe6f72bb793043cac78af60fd" title="Returns the contents of the next frame from an endpoint.">NvSciIpcReadSafe()</a> and <a class="el" href="group__nvsci__ipc__api.html#ga2eb7f4a5c6e33a641b980ed9c3612cf1" title="Writes a new frame to the endpoint.">NvSciIpcWriteSafe()</a> is recommended rather than following Read/Write APIs. See detail constraints of API in each function description.</p><ul>
<li><a class="el" href="group__nvsci__ipc__api.html#ga0fbf020d67a2d5e53187eb7173a0514f" title="Returns a pointer to the location of the next frame from an endpoint.">NvSciIpcReadGetNextFrame()</a></li>
<li><a class="el" href="group__nvsci__ipc__api.html#ga2bc9654b0fa45c253b5cdfed4febda5d" title="Returns a pointer to the location of the next frame for writing data.">NvSciIpcWriteGetNextFrame()</a></li>
<li><a class="el" href="group__nvsci__ipc__api.html#ga80fcfa1951449da7c5f7bd6f46666cc8" title="Removes the next frame from an endpoint.">NvSciIpcReadAdvance()</a></li>
<li><a class="el" href="group__nvsci__ipc__api.html#ga338f05ed740e1ad33895469d8fa1bfdc" title="Writes the next frame to the endpoint.">NvSciIpcWriteAdvance()</a> However, above functions are better to avoid extra memory copy.</li>
</ul>
<p><b>Provide valid buffer pointers</b></p>
<p>The user of NvSciIpc must provide valid buffer pointers to <a class="el" href="group__nvsci__ipc__api.html#ga63bb5b3fe6f72bb793043cac78af60fd" title="Returns the contents of the next frame from an endpoint.">NvSciIpcReadSafe()</a>, <a class="el" href="group__nvsci__ipc__api.html#ga2eb7f4a5c6e33a641b980ed9c3612cf1" title="Writes a new frame to the endpoint.">NvSciIpcWriteSafe()</a> and other Read/Write NvSciIpc APIs as NvSciIpc library validation to these parameters is limited to a NULL pointer check.</p>
<p><b>Maximum number of endpoints</b></p>
<p>One NvSciIpc client process is allowed to open up to 500 endpoints. QNX NvSciIpc opens two device nodes in opening endpoint. QNX OS kernel supports 1024 100 open channels without disabling kernel preemption. User client needs one channel/connection pair to receive an endpoint notification.</p>
<p><b>Use ChannelCreatePulsePool() - QNX OS</b></p>
<p>In using legacy event handling (without <a class="el" href="structNvSciEventService.html" title="An abstract interface for a program&#39;s event handling infrastructure.">NvSciEventService</a>) on NvSciIpc, user has to create chid and coid using ChannelCreate_r() and ConnectAttach_r() before calling NvSciIpcSetQnxPulseParamSafe(). This ChannelCreate() uses global pulse message pool. If privileged and non-privileged processes use the same global pool, unprivileged processes can potentially interfere with privileged processes by receiving and not handling large numbers of pulses (thereby causing denial of service attack). So, ChannelCreatePulsePool() API is recommended to use fixed private pool of pulses instead of using ChannelCreate_r().</p>
<p>struct nto_channel_config { struct sigevent event; // initialize using SIGEV_SEM_INIT() macro unsigned num_pulses; // threshold to trigger semaphore event unsigned rearm_threshold; // 0 ~ num_pulses unsigned options; // _NTO_CHO_CUSTOM_EVENT unsigned reserved[3]; }</p>
<p>If you're experienced pulse pool shortage issue in normal operation, increase num_pulses by double of previous setting.</p>
<p>More information can be found in QNX OS manual page.</p>
<p>In order to detect IVC signalling storm, user needs to create separate thread to receive semaphore event which is set in nto_channel_config structure and call sem_wait() in that thread. NvSciIpcInspectEventQnx() API returns NvSciIpcEndpoint handle in which IVC signalling storm happens. User can decide post action (i.e. close endpoint, restart process, deinit NvSciIpc etc.) per system usecase scenario after detecting issue. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNvSciIpcEndpointInfo.html">NvSciIpcEndpointInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines information about the NvSciIpc endpoint.  <a href="structNvSciIpcEndpointInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga5bb111833a27a23b675e77f9b4298e2c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvsci__ipc__api.html#ga5bb111833a27a23b675e77f9b4298e2c">NVSCIIPC_MAX_ENDPOINT_NAME</a>&#160;&#160;&#160;64U</td></tr>
<tr class="memdesc:ga5bb111833a27a23b675e77f9b4298e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies maximum Endpoint name length including null terminator.  <a href="group__nvsci__ipc__api.html#ga5bb111833a27a23b675e77f9b4298e2c">More...</a><br /></td></tr>
<tr class="separator:ga5bb111833a27a23b675e77f9b4298e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4436046ffdc9524d53e2591de04f0fa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvsci__ipc__api.html#gaf4436046ffdc9524d53e2591de04f0fa">NV_SCI_IPC_EVENT_READ</a>&#160;&#160;&#160;0x01U</td></tr>
<tr class="memdesc:gaf4436046ffdc9524d53e2591de04f0fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the IPC read event.  <a href="group__nvsci__ipc__api.html#gaf4436046ffdc9524d53e2591de04f0fa">More...</a><br /></td></tr>
<tr class="separator:gaf4436046ffdc9524d53e2591de04f0fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7b1528d3c4eb51df15de78422632fa4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvsci__ipc__api.html#gae7b1528d3c4eb51df15de78422632fa4">NV_SCI_IPC_EVENT_WRITE</a>&#160;&#160;&#160;0x02U</td></tr>
<tr class="memdesc:gae7b1528d3c4eb51df15de78422632fa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the IPC write event.  <a href="group__nvsci__ipc__api.html#gae7b1528d3c4eb51df15de78422632fa4">More...</a><br /></td></tr>
<tr class="separator:gae7b1528d3c4eb51df15de78422632fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe55c85ed8467eca67b13795d001b02e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvsci__ipc__api.html#gabe55c85ed8467eca67b13795d001b02e">NV_SCI_IPC_EVENT_CONN_EST</a>&#160;&#160;&#160;0x04U</td></tr>
<tr class="memdesc:gabe55c85ed8467eca67b13795d001b02e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the IPC connection established event.  <a href="group__nvsci__ipc__api.html#gabe55c85ed8467eca67b13795d001b02e">More...</a><br /></td></tr>
<tr class="separator:gabe55c85ed8467eca67b13795d001b02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga915855a4bba2be234176ae2caa89ff24"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvsci__ipc__api.html#ga915855a4bba2be234176ae2caa89ff24">NV_SCI_IPC_EVENT_CONN_RESET</a>&#160;&#160;&#160;0x08U</td></tr>
<tr class="memdesc:ga915855a4bba2be234176ae2caa89ff24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the IPC connection reset event.  <a href="group__nvsci__ipc__api.html#ga915855a4bba2be234176ae2caa89ff24">More...</a><br /></td></tr>
<tr class="separator:ga915855a4bba2be234176ae2caa89ff24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9e1641c08767a047b6de58114a13bac"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvsci__ipc__api.html#gaa9e1641c08767a047b6de58114a13bac">NV_SCI_IPC_EVENT_WRITE_EMPTY</a>&#160;&#160;&#160;0x10U</td></tr>
<tr class="memdesc:gaa9e1641c08767a047b6de58114a13bac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the IPC write fifo empty event.  <a href="group__nvsci__ipc__api.html#gaa9e1641c08767a047b6de58114a13bac">More...</a><br /></td></tr>
<tr class="separator:gaa9e1641c08767a047b6de58114a13bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10730765f6c4abaaf38e147f7087e029"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvsci__ipc__api.html#ga10730765f6c4abaaf38e147f7087e029">NV_SCI_IPC_EVENT_CONN_EST_ALL</a></td></tr>
<tr class="memdesc:ga10730765f6c4abaaf38e147f7087e029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies single event mask to check IPC connection establishment.  <a href="group__nvsci__ipc__api.html#ga10730765f6c4abaaf38e147f7087e029">More...</a><br /></td></tr>
<tr class="separator:ga10730765f6c4abaaf38e147f7087e029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga748abda9c75a96397225b9a97fa0f900"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvsci__ipc__api.html#ga748abda9c75a96397225b9a97fa0f900">NVSCIIPC_INFINITE_WAIT</a>&#160;&#160;&#160;-1LL</td></tr>
<tr class="memdesc:ga748abda9c75a96397225b9a97fa0f900"><td class="mdescLeft">&#160;</td><td class="mdescRight">infinite timeout for NvSciIpcWaitEventQnx()  <a href="group__nvsci__ipc__api.html#ga748abda9c75a96397225b9a97fa0f900">More...</a><br /></td></tr>
<tr class="separator:ga748abda9c75a96397225b9a97fa0f900"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga59ade49463d6ce5b5ee2cc20f9cbab92"><td class="memItemLeft" align="right" valign="top">typedef uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvsci__ipc__api.html#ga59ade49463d6ce5b5ee2cc20f9cbab92">NvSciIpcEndpoint</a></td></tr>
<tr class="memdesc:ga59ade49463d6ce5b5ee2cc20f9cbab92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle to the NvSciIpc endpoint.  <a href="group__nvsci__ipc__api.html#ga59ade49463d6ce5b5ee2cc20f9cbab92">More...</a><br /></td></tr>
<tr class="separator:ga59ade49463d6ce5b5ee2cc20f9cbab92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f6897757ccdeced78c89e41c65c41a0"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structNvSciIpcEndpointInfo.html">NvSciIpcEndpointInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvsci__ipc__api.html#ga5f6897757ccdeced78c89e41c65c41a0">NvSciIpcEndpointInfo</a></td></tr>
<tr class="separator:ga5f6897757ccdeced78c89e41c65c41a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9d1e5e9447b89ea626616fdf7d2dbe91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938">NvSciError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvsci__ipc__api.html#ga9d1e5e9447b89ea626616fdf7d2dbe91">NvSciIpcInit</a> (void)</td></tr>
<tr class="memdesc:ga9d1e5e9447b89ea626616fdf7d2dbe91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the NvSciIpc library.  <a href="group__nvsci__ipc__api.html#ga9d1e5e9447b89ea626616fdf7d2dbe91">More...</a><br /></td></tr>
<tr class="separator:ga9d1e5e9447b89ea626616fdf7d2dbe91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc2132de8f3f32e62e7a297f67e8da9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvsci__ipc__api.html#gabc2132de8f3f32e62e7a297f67e8da9d">NvSciIpcDeinit</a> (void)</td></tr>
<tr class="memdesc:gabc2132de8f3f32e62e7a297f67e8da9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-initializes the NvSciIpc library.  <a href="group__nvsci__ipc__api.html#gabc2132de8f3f32e62e7a297f67e8da9d">More...</a><br /></td></tr>
<tr class="separator:gabc2132de8f3f32e62e7a297f67e8da9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3acc28ad8a4ebe4d8175c70324424094"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938">NvSciError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvsci__ipc__api.html#ga3acc28ad8a4ebe4d8175c70324424094">NvSciIpcOpenEndpoint</a> (const char *endpoint, <a class="el" href="group__nvsci__ipc__api.html#ga59ade49463d6ce5b5ee2cc20f9cbab92">NvSciIpcEndpoint</a> *handle)</td></tr>
<tr class="memdesc:ga3acc28ad8a4ebe4d8175c70324424094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens an endpoint with the given name.  <a href="group__nvsci__ipc__api.html#ga3acc28ad8a4ebe4d8175c70324424094">More...</a><br /></td></tr>
<tr class="separator:ga3acc28ad8a4ebe4d8175c70324424094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1386ae6969f2b8d52e8eaacb248d6ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938">NvSciError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvsci__ipc__api.html#gaa1386ae6969f2b8d52e8eaacb248d6ae">NvSciIpcOpenEndpointWithEventService</a> (const char *endpoint, <a class="el" href="group__nvsci__ipc__api.html#ga59ade49463d6ce5b5ee2cc20f9cbab92">NvSciIpcEndpoint</a> *handle, <a class="el" href="structNvSciEventService.html">NvSciEventService</a> *eventService)</td></tr>
<tr class="memdesc:gaa1386ae6969f2b8d52e8eaacb248d6ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens an endpoint with the given name and event service.  <a href="group__nvsci__ipc__api.html#gaa1386ae6969f2b8d52e8eaacb248d6ae">More...</a><br /></td></tr>
<tr class="separator:gaa1386ae6969f2b8d52e8eaacb248d6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75c70be08614ce8d81526edf3cdaeefa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938">NvSciError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvsci__ipc__api.html#ga75c70be08614ce8d81526edf3cdaeefa">NvSciIpcGetEventNotifier</a> (<a class="el" href="group__nvsci__ipc__api.html#ga59ade49463d6ce5b5ee2cc20f9cbab92">NvSciIpcEndpoint</a> handle, <a class="el" href="structNvSciEventNotifier.html">NvSciEventNotifier</a> **eventNotifier)</td></tr>
<tr class="memdesc:ga75c70be08614ce8d81526edf3cdaeefa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get NvSciIpc event notifier.  <a href="group__nvsci__ipc__api.html#ga75c70be08614ce8d81526edf3cdaeefa">More...</a><br /></td></tr>
<tr class="separator:ga75c70be08614ce8d81526edf3cdaeefa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga602f50580c2735ed3a04dd519c314763"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvsci__ipc__api.html#ga602f50580c2735ed3a04dd519c314763">NvSciIpcCloseEndpoint</a> (<a class="el" href="group__nvsci__ipc__api.html#ga59ade49463d6ce5b5ee2cc20f9cbab92">NvSciIpcEndpoint</a> handle)</td></tr>
<tr class="memdesc:ga602f50580c2735ed3a04dd519c314763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes an endpoint with the given handle.  <a href="group__nvsci__ipc__api.html#ga602f50580c2735ed3a04dd519c314763">More...</a><br /></td></tr>
<tr class="separator:ga602f50580c2735ed3a04dd519c314763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5bef8557494be3e426950bf49ba24dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938">NvSciError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvsci__ipc__api.html#gab5bef8557494be3e426950bf49ba24dd">NvSciIpcCloseEndpointSafe</a> (<a class="el" href="group__nvsci__ipc__api.html#ga59ade49463d6ce5b5ee2cc20f9cbab92">NvSciIpcEndpoint</a> handle, bool clear)</td></tr>
<tr class="memdesc:gab5bef8557494be3e426950bf49ba24dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes an endpoint with the given handle (safety version)  <a href="group__nvsci__ipc__api.html#gab5bef8557494be3e426950bf49ba24dd">More...</a><br /></td></tr>
<tr class="separator:gab5bef8557494be3e426950bf49ba24dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3dd21216a75c3c14303fd83c968e96a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvsci__ipc__api.html#gab3dd21216a75c3c14303fd83c968e96a">NvSciIpcResetEndpoint</a> (<a class="el" href="group__nvsci__ipc__api.html#ga59ade49463d6ce5b5ee2cc20f9cbab92">NvSciIpcEndpoint</a> handle)</td></tr>
<tr class="memdesc:gab3dd21216a75c3c14303fd83c968e96a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets an endpoint.  <a href="group__nvsci__ipc__api.html#gab3dd21216a75c3c14303fd83c968e96a">More...</a><br /></td></tr>
<tr class="separator:gab3dd21216a75c3c14303fd83c968e96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93831442d2f06ef6ec4787bf6ec76c7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938">NvSciError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvsci__ipc__api.html#ga93831442d2f06ef6ec4787bf6ec76c7c">NvSciIpcResetEndpointSafe</a> (<a class="el" href="group__nvsci__ipc__api.html#ga59ade49463d6ce5b5ee2cc20f9cbab92">NvSciIpcEndpoint</a> handle)</td></tr>
<tr class="memdesc:ga93831442d2f06ef6ec4787bf6ec76c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets an endpoint.  <a href="group__nvsci__ipc__api.html#ga93831442d2f06ef6ec4787bf6ec76c7c">More...</a><br /></td></tr>
<tr class="separator:ga93831442d2f06ef6ec4787bf6ec76c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eabb25c5ac0457990a2a7535ef0e870"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938">NvSciError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvsci__ipc__api.html#ga0eabb25c5ac0457990a2a7535ef0e870">NvSciIpcRead</a> (<a class="el" href="group__nvsci__ipc__api.html#ga59ade49463d6ce5b5ee2cc20f9cbab92">NvSciIpcEndpoint</a> handle, void *buf, size_t size, int32_t *bytes)</td></tr>
<tr class="memdesc:ga0eabb25c5ac0457990a2a7535ef0e870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contents of the next frame from an endpoint.  <a href="group__nvsci__ipc__api.html#ga0eabb25c5ac0457990a2a7535ef0e870">More...</a><br /></td></tr>
<tr class="separator:ga0eabb25c5ac0457990a2a7535ef0e870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63bb5b3fe6f72bb793043cac78af60fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938">NvSciError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvsci__ipc__api.html#ga63bb5b3fe6f72bb793043cac78af60fd">NvSciIpcReadSafe</a> (<a class="el" href="group__nvsci__ipc__api.html#ga59ade49463d6ce5b5ee2cc20f9cbab92">NvSciIpcEndpoint</a> handle, void *buf, uint32_t size, uint32_t *bytes)</td></tr>
<tr class="memdesc:ga63bb5b3fe6f72bb793043cac78af60fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contents of the next frame from an endpoint.  <a href="group__nvsci__ipc__api.html#ga63bb5b3fe6f72bb793043cac78af60fd">More...</a><br /></td></tr>
<tr class="separator:ga63bb5b3fe6f72bb793043cac78af60fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fbf020d67a2d5e53187eb7173a0514f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938">NvSciError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvsci__ipc__api.html#ga0fbf020d67a2d5e53187eb7173a0514f">NvSciIpcReadGetNextFrame</a> (<a class="el" href="group__nvsci__ipc__api.html#ga59ade49463d6ce5b5ee2cc20f9cbab92">NvSciIpcEndpoint</a> handle, const volatile void **buf)</td></tr>
<tr class="memdesc:ga0fbf020d67a2d5e53187eb7173a0514f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the location of the next frame from an endpoint.  <a href="group__nvsci__ipc__api.html#ga0fbf020d67a2d5e53187eb7173a0514f">More...</a><br /></td></tr>
<tr class="separator:ga0fbf020d67a2d5e53187eb7173a0514f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80fcfa1951449da7c5f7bd6f46666cc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938">NvSciError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvsci__ipc__api.html#ga80fcfa1951449da7c5f7bd6f46666cc8">NvSciIpcReadAdvance</a> (<a class="el" href="group__nvsci__ipc__api.html#ga59ade49463d6ce5b5ee2cc20f9cbab92">NvSciIpcEndpoint</a> handle)</td></tr>
<tr class="memdesc:ga80fcfa1951449da7c5f7bd6f46666cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the next frame from an endpoint.  <a href="group__nvsci__ipc__api.html#ga80fcfa1951449da7c5f7bd6f46666cc8">More...</a><br /></td></tr>
<tr class="separator:ga80fcfa1951449da7c5f7bd6f46666cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c0266eb2aaef1ec32ac31a479a6ee23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938">NvSciError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvsci__ipc__api.html#ga6c0266eb2aaef1ec32ac31a479a6ee23">NvSciIpcWrite</a> (<a class="el" href="group__nvsci__ipc__api.html#ga59ade49463d6ce5b5ee2cc20f9cbab92">NvSciIpcEndpoint</a> handle, const void *buf, size_t size, int32_t *bytes)</td></tr>
<tr class="memdesc:ga6c0266eb2aaef1ec32ac31a479a6ee23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a new frame to the endpoint.  <a href="group__nvsci__ipc__api.html#ga6c0266eb2aaef1ec32ac31a479a6ee23">More...</a><br /></td></tr>
<tr class="separator:ga6c0266eb2aaef1ec32ac31a479a6ee23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2eb7f4a5c6e33a641b980ed9c3612cf1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938">NvSciError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvsci__ipc__api.html#ga2eb7f4a5c6e33a641b980ed9c3612cf1">NvSciIpcWriteSafe</a> (<a class="el" href="group__nvsci__ipc__api.html#ga59ade49463d6ce5b5ee2cc20f9cbab92">NvSciIpcEndpoint</a> handle, const void *buf, uint32_t size, uint32_t *bytes)</td></tr>
<tr class="memdesc:ga2eb7f4a5c6e33a641b980ed9c3612cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a new frame to the endpoint.  <a href="group__nvsci__ipc__api.html#ga2eb7f4a5c6e33a641b980ed9c3612cf1">More...</a><br /></td></tr>
<tr class="separator:ga2eb7f4a5c6e33a641b980ed9c3612cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bc9654b0fa45c253b5cdfed4febda5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938">NvSciError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvsci__ipc__api.html#ga2bc9654b0fa45c253b5cdfed4febda5d">NvSciIpcWriteGetNextFrame</a> (<a class="el" href="group__nvsci__ipc__api.html#ga59ade49463d6ce5b5ee2cc20f9cbab92">NvSciIpcEndpoint</a> handle, volatile void **buf)</td></tr>
<tr class="memdesc:ga2bc9654b0fa45c253b5cdfed4febda5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the location of the next frame for writing data.  <a href="group__nvsci__ipc__api.html#ga2bc9654b0fa45c253b5cdfed4febda5d">More...</a><br /></td></tr>
<tr class="separator:ga2bc9654b0fa45c253b5cdfed4febda5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga338f05ed740e1ad33895469d8fa1bfdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938">NvSciError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvsci__ipc__api.html#ga338f05ed740e1ad33895469d8fa1bfdc">NvSciIpcWriteAdvance</a> (<a class="el" href="group__nvsci__ipc__api.html#ga59ade49463d6ce5b5ee2cc20f9cbab92">NvSciIpcEndpoint</a> handle)</td></tr>
<tr class="memdesc:ga338f05ed740e1ad33895469d8fa1bfdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the next frame to the endpoint.  <a href="group__nvsci__ipc__api.html#ga338f05ed740e1ad33895469d8fa1bfdc">More...</a><br /></td></tr>
<tr class="separator:ga338f05ed740e1ad33895469d8fa1bfdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga962dca348abb1e7066709464f19cbc35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938">NvSciError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvsci__ipc__api.html#ga962dca348abb1e7066709464f19cbc35">NvSciIpcGetEndpointInfo</a> (<a class="el" href="group__nvsci__ipc__api.html#ga59ade49463d6ce5b5ee2cc20f9cbab92">NvSciIpcEndpoint</a> handle, <a class="el" href="structNvSciIpcEndpointInfo.html">NvSciIpcEndpointInfo</a> *info)</td></tr>
<tr class="memdesc:ga962dca348abb1e7066709464f19cbc35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns endpoint information.  <a href="group__nvsci__ipc__api.html#ga962dca348abb1e7066709464f19cbc35">More...</a><br /></td></tr>
<tr class="separator:ga962dca348abb1e7066709464f19cbc35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17c8f735886735c578222acb63761abf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938">NvSciError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvsci__ipc__api.html#ga17c8f735886735c578222acb63761abf">NvSciIpcGetLinuxEventFd</a> (<a class="el" href="group__nvsci__ipc__api.html#ga59ade49463d6ce5b5ee2cc20f9cbab92">NvSciIpcEndpoint</a> handle, int32_t *fd)</td></tr>
<tr class="memdesc:ga17c8f735886735c578222acb63761abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the NvSciIpc file descriptor for a given endpoint.  <a href="group__nvsci__ipc__api.html#ga17c8f735886735c578222acb63761abf">More...</a><br /></td></tr>
<tr class="separator:ga17c8f735886735c578222acb63761abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0c8482abc29cc356f0c73ed0cca1bd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938">NvSciError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvsci__ipc__api.html#gac0c8482abc29cc356f0c73ed0cca1bd4">NvSciIpcGetEvent</a> (<a class="el" href="group__nvsci__ipc__api.html#ga59ade49463d6ce5b5ee2cc20f9cbab92">NvSciIpcEndpoint</a> handle, uint32_t *events)</td></tr>
<tr class="memdesc:gac0c8482abc29cc356f0c73ed0cca1bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Events.  <a href="group__nvsci__ipc__api.html#gac0c8482abc29cc356f0c73ed0cca1bd4">More...</a><br /></td></tr>
<tr class="separator:gac0c8482abc29cc356f0c73ed0cca1bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1130185389f6912fd565206ce869628"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938">NvSciError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvsci__ipc__api.html#gab1130185389f6912fd565206ce869628">NvSciIpcGetEventSafe</a> (<a class="el" href="group__nvsci__ipc__api.html#ga59ade49463d6ce5b5ee2cc20f9cbab92">NvSciIpcEndpoint</a> handle, uint32_t *events)</td></tr>
<tr class="memdesc:gab1130185389f6912fd565206ce869628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get Events (safety version)  <a href="group__nvsci__ipc__api.html#gab1130185389f6912fd565206ce869628">More...</a><br /></td></tr>
<tr class="separator:gab1130185389f6912fd565206ce869628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0d9cb1267ba9c8ac0c97b33a3e970a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938">NvSciError</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvsci__ipc__api.html#gac0d9cb1267ba9c8ac0c97b33a3e970a9">NvSciIpcCheckVersionCompatibility</a> (uint32_t majorVer, uint32_t minorVer, bool *isCompatible)</td></tr>
<tr class="separator:gac0d9cb1267ba9c8ac0c97b33a3e970a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gabe55c85ed8467eca67b13795d001b02e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe55c85ed8467eca67b13795d001b02e">&#9670;&nbsp;</a></span>NV_SCI_IPC_EVENT_CONN_EST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NV_SCI_IPC_EVENT_CONN_EST&#160;&#160;&#160;0x04U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the IPC connection established event. </p>

<p class="definition">Definition at line <a class="el" href="nvsciipc_8h_source.html#l00310">310</a> of file <a class="el" href="nvsciipc_8h_source.html">nvsciipc.h</a>.</p>

</div>
</div>
<a id="ga10730765f6c4abaaf38e147f7087e029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10730765f6c4abaaf38e147f7087e029">&#9670;&nbsp;</a></span>NV_SCI_IPC_EVENT_CONN_EST_ALL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NV_SCI_IPC_EVENT_CONN_EST_ALL</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    (<a class="code" href="group__nvsci__ipc__api.html#gabe55c85ed8467eca67b13795d001b02e">NV_SCI_IPC_EVENT_CONN_EST</a> | \</div>
<div class="line">    NV_SCI_IPC_EVENT_WRITE | <a class="code" href="group__nvsci__ipc__api.html#gaa9e1641c08767a047b6de58114a13bac">NV_SCI_IPC_EVENT_WRITE_EMPTY</a> | \</div>
<div class="line">    NV_SCI_IPC_EVENT_READ)</div>
</div><!-- fragment -->
<p>Specifies single event mask to check IPC connection establishment. </p>

<p class="definition">Definition at line <a class="el" href="nvsciipc_8h_source.html#l00316">316</a> of file <a class="el" href="nvsciipc_8h_source.html">nvsciipc.h</a>.</p>

</div>
</div>
<a id="ga915855a4bba2be234176ae2caa89ff24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga915855a4bba2be234176ae2caa89ff24">&#9670;&nbsp;</a></span>NV_SCI_IPC_EVENT_CONN_RESET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NV_SCI_IPC_EVENT_CONN_RESET&#160;&#160;&#160;0x08U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the IPC connection reset event. </p>

<p class="definition">Definition at line <a class="el" href="nvsciipc_8h_source.html#l00312">312</a> of file <a class="el" href="nvsciipc_8h_source.html">nvsciipc.h</a>.</p>

</div>
</div>
<a id="gaf4436046ffdc9524d53e2591de04f0fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4436046ffdc9524d53e2591de04f0fa">&#9670;&nbsp;</a></span>NV_SCI_IPC_EVENT_READ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NV_SCI_IPC_EVENT_READ&#160;&#160;&#160;0x01U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the IPC read event. </p>

<p class="definition">Definition at line <a class="el" href="nvsciipc_8h_source.html#l00306">306</a> of file <a class="el" href="nvsciipc_8h_source.html">nvsciipc.h</a>.</p>

</div>
</div>
<a id="gae7b1528d3c4eb51df15de78422632fa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7b1528d3c4eb51df15de78422632fa4">&#9670;&nbsp;</a></span>NV_SCI_IPC_EVENT_WRITE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NV_SCI_IPC_EVENT_WRITE&#160;&#160;&#160;0x02U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the IPC write event. </p>

<p class="definition">Definition at line <a class="el" href="nvsciipc_8h_source.html#l00308">308</a> of file <a class="el" href="nvsciipc_8h_source.html">nvsciipc.h</a>.</p>

</div>
</div>
<a id="gaa9e1641c08767a047b6de58114a13bac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9e1641c08767a047b6de58114a13bac">&#9670;&nbsp;</a></span>NV_SCI_IPC_EVENT_WRITE_EMPTY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NV_SCI_IPC_EVENT_WRITE_EMPTY&#160;&#160;&#160;0x10U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the IPC write fifo empty event. </p>

<p class="definition">Definition at line <a class="el" href="nvsciipc_8h_source.html#l00314">314</a> of file <a class="el" href="nvsciipc_8h_source.html">nvsciipc.h</a>.</p>

</div>
</div>
<a id="ga748abda9c75a96397225b9a97fa0f900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga748abda9c75a96397225b9a97fa0f900">&#9670;&nbsp;</a></span>NVSCIIPC_INFINITE_WAIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NVSCIIPC_INFINITE_WAIT&#160;&#160;&#160;-1LL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>infinite timeout for NvSciIpcWaitEventQnx() </p>

<p class="definition">Definition at line <a class="el" href="nvsciipc_8h_source.html#l00321">321</a> of file <a class="el" href="nvsciipc_8h_source.html">nvsciipc.h</a>.</p>

</div>
</div>
<a id="ga5bb111833a27a23b675e77f9b4298e2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5bb111833a27a23b675e77f9b4298e2c">&#9670;&nbsp;</a></span>NVSCIIPC_MAX_ENDPOINT_NAME</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NVSCIIPC_MAX_ENDPOINT_NAME&#160;&#160;&#160;64U</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies maximum Endpoint name length including null terminator. </p>

<p class="definition">Definition at line <a class="el" href="nvsciipc_8h_source.html#l00302">302</a> of file <a class="el" href="nvsciipc_8h_source.html">nvsciipc.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga59ade49463d6ce5b5ee2cc20f9cbab92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59ade49463d6ce5b5ee2cc20f9cbab92">&#9670;&nbsp;</a></span>NvSciIpcEndpoint</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint64_t <a class="el" href="group__nvsci__ipc__api.html#ga59ade49463d6ce5b5ee2cc20f9cbab92">NvSciIpcEndpoint</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle to the NvSciIpc endpoint. </p>

<p class="definition">Definition at line <a class="el" href="nvsciipc_8h_source.html#l00284">284</a> of file <a class="el" href="nvsciipc_8h_source.html">nvsciipc.h</a>.</p>

</div>
</div>
<a id="ga5f6897757ccdeced78c89e41c65c41a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f6897757ccdeced78c89e41c65c41a0">&#9670;&nbsp;</a></span>NvSciIpcEndpointInfo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structNvSciIpcEndpointInfo.html">NvSciIpcEndpointInfo</a> <a class="el" href="structNvSciIpcEndpointInfo.html">NvSciIpcEndpointInfo</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="nvsciipc_8h_source.html#l00286">286</a> of file <a class="el" href="nvsciipc_8h_source.html">nvsciipc.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gac0d9cb1267ba9c8ac0c97b33a3e970a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0d9cb1267ba9c8ac0c97b33a3e970a9">&#9670;&nbsp;</a></span>NvSciIpcCheckVersionCompatibility()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938">NvSciError</a> NvSciIpcCheckVersionCompatibility </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>majorVer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>minorVer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>isCompatible</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga602f50580c2735ed3a04dd519c314763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga602f50580c2735ed3a04dd519c314763">&#9670;&nbsp;</a></span>NvSciIpcCloseEndpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NvSciIpcCloseEndpoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvsci__ipc__api.html#ga59ade49463d6ce5b5ee2cc20f9cbab92">NvSciIpcEndpoint</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes an endpoint with the given handle. </p>
<dl class="section warning"><dt>Warning</dt><dd>This API will be deprecated in future release. Use <a class="el" href="group__nvsci__ipc__api.html#gab5bef8557494be3e426950bf49ba24dd" title="Closes an endpoint with the given handle (safety version)">NvSciIpcCloseEndpointSafe()</a> instead of this.</dd></dl>
<p>The function frees the NvSciIpc endpoint associated with the given <em>handle</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>A handle to the endpoint to close.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>void</code> </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Invocation of <a class="el" href="group__nvsci__ipc__api.html#ga3acc28ad8a4ebe4d8175c70324424094" title="Opens an endpoint with the given name.">NvSciIpcOpenEndpoint()</a> must be successful.</dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: Yes</li>
<li>Async/Sync: Sync</li>
</ul>
</li>
<li>Required Privileges(QNX): None</li>
<li>API Group<ul>
<li>Init: No</li>
<li>Runtime: No</li>
<li>De-Init: Yes </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="gab5bef8557494be3e426950bf49ba24dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5bef8557494be3e426950bf49ba24dd">&#9670;&nbsp;</a></span>NvSciIpcCloseEndpointSafe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938">NvSciError</a> NvSciIpcCloseEndpointSafe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvsci__ipc__api.html#ga59ade49463d6ce5b5ee2cc20f9cbab92">NvSciIpcEndpoint</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clear</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes an endpoint with the given handle (safety version) </p>
<p>The function frees the NvSciIpc endpoint associated with the given <em>handle</em>. The remote endpoint may lose data in TX queue if this API is called with <em>clear</em> flag before remote endpoint reads the data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>A handle to the endpoint to close. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clear</td><td>flag to clear whole TX queue buffer for security.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938" title="Return/error codes for all NvSci functions.">NvSciError</a>, the completion code of the operation:<ul>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938ae40bf61f6e341173fd828847232228f7" title="[EOK] No error">NvSciError_Success</a> Indicates a successful operation.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a544a45defff9378e5cf10fc67d05eaf9" title="[EINVAL] Invalid parameter value">NvSciError_BadParameter</a> Indicates an invalid <em>handle</em>.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a4c7e4f51a82124c413388e723da685b9" title="Required resource is not initialized.">NvSciError_NotInitialized</a> Indicates NvSciIpc is uninitialized.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Invocation of <a class="el" href="group__nvsci__ipc__api.html#ga3acc28ad8a4ebe4d8175c70324424094" title="Opens an endpoint with the given name.">NvSciIpcOpenEndpoint()</a> must be successful.</dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: Yes</li>
<li>Async/Sync: Sync</li>
</ul>
</li>
<li>Required Privileges(QNX): None</li>
<li>API Group<ul>
<li>Init: No</li>
<li>Runtime: No</li>
<li>De-Init: Yes </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="gabc2132de8f3f32e62e7a297f67e8da9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc2132de8f3f32e62e7a297f67e8da9d">&#9670;&nbsp;</a></span>NvSciIpcDeinit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NvSciIpcDeinit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-initializes the NvSciIpc library. </p>
<p>This function cleans up the NvSciIpc endpoint internal database created by <a class="el" href="group__nvsci__ipc__api.html#ga9d1e5e9447b89ea626616fdf7d2dbe91" title="Initializes the NvSciIpc library.">NvSciIpcInit()</a>. Before calling this API, all existing opened endpoints must be closed by <a class="el" href="group__nvsci__ipc__api.html#gab5bef8557494be3e426950bf49ba24dd" title="Closes an endpoint with the given handle (safety version)">NvSciIpcCloseEndpointSafe()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>void</code> </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Invocation of <a class="el" href="group__nvsci__ipc__api.html#ga9d1e5e9447b89ea626616fdf7d2dbe91" title="Initializes the NvSciIpc library.">NvSciIpcInit()</a> must be successful.</dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: Yes</li>
<li>Async/Sync: Sync</li>
</ul>
</li>
<li>Required Privileges(QNX): None</li>
<li>API Group<ul>
<li>Init: No</li>
<li>Runtime: No</li>
<li>De-Init: Yes </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="ga962dca348abb1e7066709464f19cbc35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga962dca348abb1e7066709464f19cbc35">&#9670;&nbsp;</a></span>NvSciIpcGetEndpointInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938">NvSciError</a> NvSciIpcGetEndpointInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvsci__ipc__api.html#ga59ade49463d6ce5b5ee2cc20f9cbab92">NvSciIpcEndpoint</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structNvSciIpcEndpointInfo.html">NvSciIpcEndpointInfo</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns endpoint information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>NvSciIpc endpoint handle. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">info</td><td>A pointer to <a class="el" href="structNvSciIpcEndpointInfo.html" title="Defines information about the NvSciIpc endpoint.">NvSciIpcEndpointInfo</a> object that this function copies the info to on success.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938" title="Return/error codes for all NvSci functions.">NvSciError</a>, the completion code of the operation:<ul>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938ae40bf61f6e341173fd828847232228f7" title="[EOK] No error">NvSciError_Success</a> Indicates a successful operation.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a4c7e4f51a82124c413388e723da685b9" title="Required resource is not initialized.">NvSciError_NotInitialized</a> Indicates NvSciIpc is uninitialized.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a544a45defff9378e5cf10fc67d05eaf9" title="[EINVAL] Invalid parameter value">NvSciError_BadParameter</a> Indicates an invalid or NULL argument.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a075b2f546b586c49a99b681bb751a53a" title="[ENOTSUP] Feature is not supported">NvSciError_NotSupported</a> Indicates API is not supported in provided endpoint backend type.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a9ae3de2bb86075c82b9c249152863749" title="Resource is in wrong state to perform operation.">NvSciError_InvalidState</a> Indicates an invalid operation state.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Invocation of <a class="el" href="group__nvsci__ipc__api.html#ga3acc28ad8a4ebe4d8175c70324424094" title="Opens an endpoint with the given name.">NvSciIpcOpenEndpoint()</a> must be successful.</dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: Yes</li>
<li>Async/Sync: Sync</li>
</ul>
</li>
<li>Required Privileges(QNX): None</li>
<li>API Group<ul>
<li>Init: Yes</li>
<li>Runtime: Yes</li>
<li>De-Init: No </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="gac0c8482abc29cc356f0c73ed0cca1bd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0c8482abc29cc356f0c73ed0cca1bd4">&#9670;&nbsp;</a></span>NvSciIpcGetEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938">NvSciError</a> NvSciIpcGetEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvsci__ipc__api.html#ga59ade49463d6ce5b5ee2cc20f9cbab92">NvSciIpcEndpoint</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>events</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Events. </p>
<dl class="section warning"><dt>Warning</dt><dd>This API will be deprecated in future release. Use <a class="el" href="group__nvsci__ipc__api.html#gab1130185389f6912fd565206ce869628" title="Get Events (safety version)">NvSciIpcGetEventSafe()</a> instead of this.</dd></dl>
<p>Returns a bitwise OR operation on new events that occurred since the last call to this function.</p>
<p>This function sets <em>events</em> to the result of a bitwise OR operation of zero or more <code>NV_SCI_IPC_EVENT_*</code> constants corresponding to all new events that have occurred on the endpoint since:</p><ul>
<li>the preceding call to this function on the endpoint or</li>
<li>opening the endpoint, if this is the first call to this function on the endpoint since it was opened.</li>
</ul>
<p>The parameter <em>events</em> is set to zero if no new events have occurred.</p>
<p>There are four types of events:</p><ul>
<li><code>NV_SCI_IPC_EVENT_CONN_EST</code> : IPC connection established</li>
<li><code>NV_SCI_IPC_EVENT_WRITE</code> : IPC write</li>
<li><code>NV_SCI_IPC_EVENT_READ</code> : IPC read</li>
<li><code>NV_SCI_IPC_EVENT_CONN_RESET</code> : IPC connection reset</li>
</ul>
<p>These may occur in arbitrary combinations, except for the following:</p><ul>
<li><code>NV_SCI_IPC_EVENT_CONN_EST</code> is always combined with <code>NV_SCI_IPC_EVENT_WRITE</code>.</li>
<li><code>NV_SCI_IPC_EVENT_CONN_RESET</code> cannot be combined with any other events.</li>
</ul>
<p>There are seven possible event combinations:</p><ul>
<li>0</li>
<li><code>NV_SCI_IPC_EVENT_CONN_EST</code> and <code>NV_SCI_IPC_EVENT_WRITE</code> </li>
<li><code>NV_SCI_IPC_EVENT_CONN_EST</code> and <code>NV_SCI_IPC_EVENT_WRITE</code> and <code>NV_SCI_IPC_EVENT_READ</code> </li>
<li><code>NV_SCI_IPC_EVENT_READ</code> </li>
<li><code>NV_SCI_IPC_EVENT_WRITE</code> </li>
<li><code>NV_SCI_IPC_EVENT_WRITE</code> and <code>NV_SCI_IPC_EVENT_READ</code> </li>
<li><code>NV_SCI_IPC_EVENT_CONN_RESET</code> </li>
</ul>
<p>An <code>NV_SCI_IPC_EVENT_CONN_EST</code> event occurs on an endpoint each time a connection is established through the endpoint (between the endpoint and the other end of the corresponding channel).</p>
<p>An <code>NV_SCI_IPC_EVENT_WRITE</code> event occurs on an endpoint:</p><ol type="1">
<li>In conjunction with the delivery of each <code>NV_SCI_IPC_CONN_EST</code> event.</li>
<li>Each time the endpoint ceases to be full after a prior <code>NvSciIpcWrite*</code> call returned <code>NvSciError_InsufficientMemory</code>. Note however that an implementation is permitted to delay the delivery of this type of <code>NV_SCI_IPC_EVENT_WRITE</code> event, e.g., for purposes of improving throughput.</li>
</ol>
<p>An <code>NV_SCI_IPC_EVENT_READ</code> event occurs on an endpoint:</p><ol type="1">
<li>In conjunction with the delivery of each <code>NV_SCI_IPC_EVENT_CONN_EST</code> event, if frames can already be read as of delivery.</li>
<li>Each time the endpoint ceases to be empty after a prior <code>NvSciRead*</code> call returned <code>NvSciError_InsufficientMemory</code>. Note however that an implementation is permitted to delay the delivery of this type of <code>NV_SCI_IPC_EVENT_READ</code> event, e.g., for purposes of improving throughput.</li>
</ol>
<p>An <code>NV_SCI_IPC_EVENT_CONN_RESET</code> event occurs on an endpoint when the user calls NvSciIpcResetEndpoint.</p>
<p>If this function doesn't return desired events, user must call OS-provided blocking API to wait for notification from remote endpoint.</p>
<p>The following are blocking API examples:</p><ul>
<li>QNX : NvSciIpcWaitEventQnx()</li>
<li>LINUX: select(), epoll() etc.</li>
<li><a class="el" href="structNvSciEventService.html" title="An abstract interface for a program&#39;s event handling infrastructure.">NvSciEventService</a>: <a class="el" href="structNvSciEventLoopService.html#aec8fc738a7a9af6460f9f31d72d4ced7" title="Waits up to a configurable timeout for a particular event notification, servicing events with configu...">NvSciEventLoopService::WaitForEvent()</a>, <br  />
 <a class="el" href="structNvSciEventLoopService.html#a2455650b85b83010a1e6d3fc93af2277" title="Waits up to a configurable timeout for any of a set of particular event notifications,...">NvSciEventLoopService::WaitForMultipleEvents()</a></li>
</ul>
<p>In case of QNX OS, in order to authenticate user client process, NvSciIpc uses custom ability "NvSciIpcEndpoint". Use procmgr_ability_lookup() QNX OS API to get ability ID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>NvSciIpc endpoint handle. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">events</td><td>A pointer to the variable into which to store the bitwise OR result of new events on success.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938" title="Return/error codes for all NvSci functions.">NvSciError</a>, the completion code of the operation:<ul>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938ae40bf61f6e341173fd828847232228f7" title="[EOK] No error">NvSciError_Success</a> Indicates a successful operation.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a4c7e4f51a82124c413388e723da685b9" title="Required resource is not initialized.">NvSciError_NotInitialized</a> Indicates NvSciIpc is uninitialized.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a544a45defff9378e5cf10fc67d05eaf9" title="[EINVAL] Invalid parameter value">NvSciError_BadParameter</a> Indicates an invalid or NULL argument.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a9ae3de2bb86075c82b9c249152863749" title="Resource is in wrong state to perform operation.">NvSciError_InvalidState</a> Indicates an invalid operation state.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a075b2f546b586c49a99b681bb751a53a" title="[ENOTSUP] Feature is not supported">NvSciError_NotSupported</a> Indicates API is not supported in provided endpoint backend type.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="group__nvsci__ipc__api.html#ga93831442d2f06ef6ec4787bf6ec76c7c" title="Resets an endpoint.">NvSciIpcResetEndpointSafe()</a> must be successful.</dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: Yes</li>
<li>Async/Sync: Sync</li>
</ul>
</li>
<li>Required Privileges(QNX): PROCMGR_AID_MEM_PHYS, "NvSciIpcEndpoint"</li>
<li>API Group<ul>
<li>Init: Yes</li>
<li>Runtime: Yes</li>
<li>De-Init: No </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="ga75c70be08614ce8d81526edf3cdaeefa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75c70be08614ce8d81526edf3cdaeefa">&#9670;&nbsp;</a></span>NvSciIpcGetEventNotifier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938">NvSciError</a> NvSciIpcGetEventNotifier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvsci__ipc__api.html#ga59ade49463d6ce5b5ee2cc20f9cbab92">NvSciIpcEndpoint</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structNvSciEventNotifier.html">NvSciEventNotifier</a> **&#160;</td>
          <td class="paramname"><em>eventNotifier</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get NvSciIpc event notifier. </p>
<p>This API is used to connect NvSciIpc event handling with OS-provided event interface. It also utilizes <a class="el" href="structNvSciEventService.html" title="An abstract interface for a program&#39;s event handling infrastructure.">NvSciEventService</a> infrastructure. Before calling <a class="el" href="group__nvsci__ipc__api.html#gab5bef8557494be3e426950bf49ba24dd" title="Closes an endpoint with the given handle (safety version)">NvSciIpcCloseEndpointSafe()</a>, event notifier should be deleted through Delete callback of <a class="el" href="structNvSciEventNotifier.html" title="An abstract interface to notify event to event consumer and to register event handler of the event co...">NvSciEventNotifier</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This API is only compatible with an endpoint that is opened with <a class="el" href="group__nvsci__ipc__api.html#gaa1386ae6969f2b8d52e8eaacb248d6ae" title="Opens an endpoint with the given name and event service.">NvSciIpcOpenEndpointWithEventService()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>NvSciIpc endpoint handle. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">eventNotifier</td><td>A pointer to <a class="el" href="structNvSciEventNotifier.html" title="An abstract interface to notify event to event consumer and to register event handler of the event co...">NvSciEventNotifier</a> object on success.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938" title="Return/error codes for all NvSci functions.">NvSciError</a>, the completion code of the operation:<ul>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938ae40bf61f6e341173fd828847232228f7" title="[EOK] No error">NvSciError_Success</a> Indicates a successful operation.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a4c7e4f51a82124c413388e723da685b9" title="Required resource is not initialized.">NvSciError_NotInitialized</a> Indicates NvSciIpc is uninitialized.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a544a45defff9378e5cf10fc67d05eaf9" title="[EINVAL] Invalid parameter value">NvSciError_BadParameter</a> Indicates an invalid or NULL argument.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a075b2f546b586c49a99b681bb751a53a" title="[ENOTSUP] Feature is not supported">NvSciError_NotSupported</a> Indicates API is not supported on provided endpoint backend type.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a9ae3de2bb86075c82b9c249152863749" title="Resource is in wrong state to perform operation.">NvSciError_InvalidState</a> Indicates an invalid operation state.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a41e2e6fb319c3d8154c3e7c84f34138a" title="[ENOMEM] Not enough memory">NvSciError_InsufficientMemory</a> Indicates memory allocation failed for the operation.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a81f0f3374fab32ea8ee1a1bd0b4bfd1a" title="Resource failed.">NvSciError_ResourceError</a> Indicates not enough system resources.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Invocation of <a class="el" href="group__nvsci__ipc__api.html#gaa1386ae6969f2b8d52e8eaacb248d6ae" title="Opens an endpoint with the given name and event service.">NvSciIpcOpenEndpointWithEventService()</a> must be successful.</dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: Yes</li>
<li>Async/Sync: Sync</li>
</ul>
</li>
<li>Required Privileges(QNX): None</li>
<li>API Group<ul>
<li>Init: Yes</li>
<li>Runtime: No</li>
<li>De-Init: No </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="gab1130185389f6912fd565206ce869628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1130185389f6912fd565206ce869628">&#9670;&nbsp;</a></span>NvSciIpcGetEventSafe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938">NvSciError</a> NvSciIpcGetEventSafe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvsci__ipc__api.html#ga59ade49463d6ce5b5ee2cc20f9cbab92">NvSciIpcEndpoint</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>events</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get Events (safety version) </p>
<p>Returns a bitwise OR operation on new events that occurred since the last call to this function.</p>
<p>This function sets <em>events</em> to the result of a bitwise OR operation of zero or more <code>NV_SCI_IPC_EVENT_*</code> constants corresponding to all new events that have occurred on the endpoint since:</p><ul>
<li>the preceding call to this function on the endpoint or</li>
<li>opening the endpoint, if this is the first call to this function on the endpoint since it was opened.</li>
</ul>
<p>The parameter <em>events</em> is set to zero if no new events have occurred.</p>
<p>There are four types of events:</p><ul>
<li><code>NV_SCI_IPC_EVENT_CONN_EST</code> : IPC connection established</li>
<li><code>NV_SCI_IPC_EVENT_WRITE</code> : IPC write</li>
<li><code>NV_SCI_IPC_EVENT_READ</code> : IPC read</li>
<li><code>NV_SCI_IPC_EVENT_CONN_RESET</code> : IPC connection reset</li>
</ul>
<p>These may occur in arbitrary combinations, except for the following:</p><ul>
<li><code>NV_SCI_IPC_EVENT_CONN_EST</code> is always combined with <code>NV_SCI_IPC_EVENT_WRITE</code>.</li>
<li><code>NV_SCI_IPC_EVENT_CONN_RESET</code> cannot be combined with any other events.</li>
</ul>
<p>There are seven possible event combinations:</p><ul>
<li>0</li>
<li><code>NV_SCI_IPC_EVENT_CONN_EST</code> and <code>NV_SCI_IPC_EVENT_WRITE</code> </li>
<li><code>NV_SCI_IPC_EVENT_CONN_EST</code> and <code>NV_SCI_IPC_EVENT_WRITE</code> and <code>NV_SCI_IPC_EVENT_READ</code> </li>
<li><code>NV_SCI_IPC_EVENT_READ</code> </li>
<li><code>NV_SCI_IPC_EVENT_WRITE</code> </li>
<li><code>NV_SCI_IPC_EVENT_WRITE</code> and <code>NV_SCI_IPC_EVENT_READ</code> </li>
<li><code>NV_SCI_IPC_EVENT_CONN_RESET</code> </li>
</ul>
<p>An <code>NV_SCI_IPC_EVENT_CONN_EST</code> event occurs on an endpoint each time a connection is established through the endpoint (between the endpoint and the other end of the corresponding channel).</p>
<p>An <code>NV_SCI_IPC_EVENT_WRITE</code> event occurs on an endpoint:</p><ol type="1">
<li>In conjunction with the delivery of each <code>NV_SCI_IPC_CONN_EST</code> event.</li>
<li>Each time the endpoint ceases to be full after a prior <code>NvSciIpcWrite*</code> call returned <code>NvSciError_InsufficientMemory</code>. Note however that an implementation is permitted to delay the delivery of this type of <code>NV_SCI_IPC_EVENT_WRITE</code> event, e.g., for purposes of improving throughput.</li>
</ol>
<p>An <code>NV_SCI_IPC_EVENT_READ</code> event occurs on an endpoint:</p><ol type="1">
<li>In conjunction with the delivery of each <code>NV_SCI_IPC_EVENT_CONN_EST</code> event, if frames can already be read as of delivery.</li>
<li>Each time the endpoint ceases to be empty after a prior <code>NvSciRead*</code> call returned <code>NvSciError_InsufficientMemory</code>. Note however that an implementation is permitted to delay the delivery of this type of <code>NV_SCI_IPC_EVENT_READ</code> event, e.g., for purposes of improving throughput.</li>
</ol>
<p>An <code>NV_SCI_IPC_EVENT_CONN_RESET</code> event occurs on an endpoint when the user calls NvSciIpcResetEndpoint.</p>
<p>If this function doesn't return desired events, user must call OS-provided blocking API to wait for notification from remote endpoint.</p>
<p>The following are blocking API examples:</p><ul>
<li>QNX : NvSciIpcWaitEventQnx()</li>
<li>LINUX: select(), epoll() etc.</li>
<li><a class="el" href="structNvSciEventService.html" title="An abstract interface for a program&#39;s event handling infrastructure.">NvSciEventService</a>: <a class="el" href="structNvSciEventLoopService.html#aec8fc738a7a9af6460f9f31d72d4ced7" title="Waits up to a configurable timeout for a particular event notification, servicing events with configu...">NvSciEventLoopService::WaitForEvent()</a>, <br  />
 <a class="el" href="structNvSciEventLoopService.html#a2455650b85b83010a1e6d3fc93af2277" title="Waits up to a configurable timeout for any of a set of particular event notifications,...">NvSciEventLoopService::WaitForMultipleEvents()</a></li>
</ul>
<p>In case of QNX OS, in order to authenticate user client process, NvSciIpc uses custom ability "NvSciIpcEndpoint". Use procmgr_ability_lookup() QNX OS API to get ability ID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>NvSciIpc endpoint handle. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">events</td><td>A pointer to the variable into which to store the bitwise OR result of new events on success.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938" title="Return/error codes for all NvSci functions.">NvSciError</a>, the completion code of the operation:<ul>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938ae40bf61f6e341173fd828847232228f7" title="[EOK] No error">NvSciError_Success</a> Indicates a successful operation.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a4c7e4f51a82124c413388e723da685b9" title="Required resource is not initialized.">NvSciError_NotInitialized</a> Indicates NvSciIpc is uninitialized.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a544a45defff9378e5cf10fc67d05eaf9" title="[EINVAL] Invalid parameter value">NvSciError_BadParameter</a> Indicates an invalid or NULL argument.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a9ae3de2bb86075c82b9c249152863749" title="Resource is in wrong state to perform operation.">NvSciError_InvalidState</a> Indicates an invalid operation state.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a075b2f546b586c49a99b681bb751a53a" title="[ENOTSUP] Feature is not supported">NvSciError_NotSupported</a> Indicates API is not supported in provided endpoint backend type.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="group__nvsci__ipc__api.html#ga93831442d2f06ef6ec4787bf6ec76c7c" title="Resets an endpoint.">NvSciIpcResetEndpointSafe()</a> must be successful.</dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: Yes</li>
<li>Async/Sync: Sync</li>
</ul>
</li>
<li>Required Privileges(QNX): PROCMGR_AID_MEM_PHYS, "NvSciIpcEndpoint"</li>
<li>API Group<ul>
<li>Init: Yes</li>
<li>Runtime: Yes</li>
<li>De-Init: No </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="ga17c8f735886735c578222acb63761abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17c8f735886735c578222acb63761abf">&#9670;&nbsp;</a></span>NvSciIpcGetLinuxEventFd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938">NvSciError</a> NvSciIpcGetLinuxEventFd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvsci__ipc__api.html#ga59ade49463d6ce5b5ee2cc20f9cbab92">NvSciIpcEndpoint</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the NvSciIpc file descriptor for a given endpoint. </p>
<p><b> This API is specific to Linux OS. </b> Event handle will be used to plug OS event notification (can be read, can be written, established, reset etc.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>NvSciIpc endpoint handle </td></tr>
    <tr><td class="paramname">fd</td><td>A pointer to the endpoint file descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938" title="Return/error codes for all NvSci functions.">NvSciError</a>, the completion code of the operation:<ul>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938ae40bf61f6e341173fd828847232228f7" title="[EOK] No error">NvSciError_Success</a> Indicates a successful operation.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a4c7e4f51a82124c413388e723da685b9" title="Required resource is not initialized.">NvSciError_NotInitialized</a> Indicates NvSciIpc is uninitialized.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a544a45defff9378e5cf10fc67d05eaf9" title="[EINVAL] Invalid parameter value">NvSciError_BadParameter</a> Indicates an invalid or NULL argument.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a075b2f546b586c49a99b681bb751a53a" title="[ENOTSUP] Feature is not supported">NvSciError_NotSupported</a> Indicates API is not supported in provided endpoint backend type or OS environment. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga9d1e5e9447b89ea626616fdf7d2dbe91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d1e5e9447b89ea626616fdf7d2dbe91">&#9670;&nbsp;</a></span>NvSciIpcInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938">NvSciError</a> NvSciIpcInit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the NvSciIpc library. </p>
<p>This function parses the NvSciIpc configuration file and creates an internal database of NvSciIpc endpoints that exist in a system.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938" title="Return/error codes for all NvSci functions.">NvSciError</a>, the completion code of the operation.<ul>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938ae40bf61f6e341173fd828847232228f7" title="[EOK] No error">NvSciError_Success</a> Indicates a successful operation.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a0c0464eb72b95ec263aa16279be57e67" title="[EPERM] No permission to perform operation">NvSciError_NotPermitted</a> Indicates initialization has failed.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a9ae3de2bb86075c82b9c249152863749" title="Resource is in wrong state to perform operation.">NvSciError_InvalidState</a> Indicates an invalid operation state.</li>
</ul>
</dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: Yes</li>
<li>Async/Sync: Sync</li>
</ul>
</li>
<li>Required Privileges(QNX): None</li>
<li>API Group<ul>
<li>Init: Yes</li>
<li>Runtime: No</li>
<li>De-Init: No </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="ga3acc28ad8a4ebe4d8175c70324424094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3acc28ad8a4ebe4d8175c70324424094">&#9670;&nbsp;</a></span>NvSciIpcOpenEndpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938">NvSciError</a> NvSciIpcOpenEndpoint </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvsci__ipc__api.html#ga59ade49463d6ce5b5ee2cc20f9cbab92">NvSciIpcEndpoint</a> *&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens an endpoint with the given name. </p>
<p>The function locates the NvSciIpc endpoint with the given name in the NvSciIpc configuration table in the internal database, and returns a handle to the endpoint if found. When the operation is successful, endpoint can utilize the allocated shared data area and the corresponding signaling mechanism setup. If the operation fails, the state of the NvSciIpc endpoint is undefined. In case of QNX OS, in order to authenticate user client process, NvSciIpc uses custom ability "NvSciIpcEndpoint". Use procmgr_ability_lookup() QNX OS API to get ability ID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">endpoint</td><td>The name of the NvSciIpc endpoint to open. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">handle</td><td>A handle to the endpoint on success.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938" title="Return/error codes for all NvSci functions.">NvSciError</a>, the completion code of the operation:<ul>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938ae40bf61f6e341173fd828847232228f7" title="[EOK] No error">NvSciError_Success</a> Indicates a successful operation.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a544a45defff9378e5cf10fc67d05eaf9" title="[EINVAL] Invalid parameter value">NvSciError_BadParameter</a> Indicates any argument was NULL or invalid.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a4c7e4f51a82124c413388e723da685b9" title="Required resource is not initialized.">NvSciError_NotInitialized</a> Indicates NvSciIpc is uninitialized.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a2d87a2948ea0eb17cf31118a7685ff59" title="[ENOENT] No such file or directory">NvSciError_NoSuchEntry</a> Indicates the <em>endpoint</em> was not found.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a8a4d3f489b06138bad71519371a52b4d" title="[EBUSY] Resource is busy">NvSciError_Busy</a> Indicates the <em>endpoint</em> is already in use.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a41e2e6fb319c3d8154c3e7c84f34138a" title="[ENOMEM] Not enough memory">NvSciError_InsufficientMemory</a> Indicates memory allocation failed for the operation.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a075b2f546b586c49a99b681bb751a53a" title="[ENOTSUP] Feature is not supported">NvSciError_NotSupported</a> Indicates API is not supported on provided endpoint backend type.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a9ae3de2bb86075c82b9c249152863749" title="Resource is in wrong state to perform operation.">NvSciError_InvalidState</a> Indicates an invalid operation state.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a0c0464eb72b95ec263aa16279be57e67" title="[EPERM] No permission to perform operation">NvSciError_NotPermitted</a> Indicates process doesn't have the required privilege.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Invocation of <a class="el" href="group__nvsci__ipc__api.html#ga9d1e5e9447b89ea626616fdf7d2dbe91" title="Initializes the NvSciIpc library.">NvSciIpcInit()</a> must be successful.</dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: Yes</li>
<li>Async/Sync: Sync</li>
</ul>
</li>
<li>Required Privileges(QNX): PROCMGR_AID_MEM_PHYS, "NvSciIpcEndpoint"</li>
<li>API Group<ul>
<li>Init: Yes</li>
<li>Runtime: No</li>
<li>De-Init: No </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="gaa1386ae6969f2b8d52e8eaacb248d6ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1386ae6969f2b8d52e8eaacb248d6ae">&#9670;&nbsp;</a></span>NvSciIpcOpenEndpointWithEventService()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938">NvSciError</a> NvSciIpcOpenEndpointWithEventService </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvsci__ipc__api.html#ga59ade49463d6ce5b5ee2cc20f9cbab92">NvSciIpcEndpoint</a> *&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structNvSciEventService.html">NvSciEventService</a> *&#160;</td>
          <td class="paramname"><em>eventService</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens an endpoint with the given name and event service. </p>
<p>This API provides same functionality as <a class="el" href="group__nvsci__ipc__api.html#ga3acc28ad8a4ebe4d8175c70324424094" title="Opens an endpoint with the given name.">NvSciIpcOpenEndpoint()</a>. But, it requires additional event service abstract object as an input parameter to utilize <a class="el" href="structNvSciEventService.html" title="An abstract interface for a program&#39;s event handling infrastructure.">NvSciEventService</a> infrastructure. <a class="el" href="structNvSciEventService.html" title="An abstract interface for a program&#39;s event handling infrastructure.">NvSciEventService</a> can be created through <a class="el" href="group__nvsci__ipc__event.html#ga9d4082ed65f56a8fc0dcc9f628816818" title="Creates a new event loop service.">NvSciEventLoopServiceCreateSafe()</a>. <a class="el" href="group__nvsci__ipc__api.html#ga75c70be08614ce8d81526edf3cdaeefa" title="Get NvSciIpc event notifier.">NvSciIpcGetEventNotifier()</a> can be used only when this API is invoked successfully. In case of QNX OS, in order to authenticate user client process, NvSciIpc uses custom ability "NvSciIpcEndpoint". Use procmgr_ability_lookup() QNX OS API to get ability ID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">endpoint</td><td>The name of the NvSciIpc endpoint to open. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">handle</td><td>A handle to the endpoint on success. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eventService</td><td>An abstract object to use <a class="el" href="structNvSciEventService.html" title="An abstract interface for a program&#39;s event handling infrastructure.">NvSciEventService</a> infrastructure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938" title="Return/error codes for all NvSci functions.">NvSciError</a>, the completion code of the operation:<ul>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938ae40bf61f6e341173fd828847232228f7" title="[EOK] No error">NvSciError_Success</a> Indicates a successful operation.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a544a45defff9378e5cf10fc67d05eaf9" title="[EINVAL] Invalid parameter value">NvSciError_BadParameter</a> Indicates any argument was NULL or invalid.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a4c7e4f51a82124c413388e723da685b9" title="Required resource is not initialized.">NvSciError_NotInitialized</a> Indicates NvSciIpc is uninitialized.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a2d87a2948ea0eb17cf31118a7685ff59" title="[ENOENT] No such file or directory">NvSciError_NoSuchEntry</a> Indicates the <em>endpoint</em> was not found.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a8a4d3f489b06138bad71519371a52b4d" title="[EBUSY] Resource is busy">NvSciError_Busy</a> Indicates the <em>endpoint</em> is already in use.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a41e2e6fb319c3d8154c3e7c84f34138a" title="[ENOMEM] Not enough memory">NvSciError_InsufficientMemory</a> Indicates memory allocation failed for the operation.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a075b2f546b586c49a99b681bb751a53a" title="[ENOTSUP] Feature is not supported">NvSciError_NotSupported</a> Indicates API is not supported on provided endpoint backend type.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a9ae3de2bb86075c82b9c249152863749" title="Resource is in wrong state to perform operation.">NvSciError_InvalidState</a> Indicates an invalid operation state.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a0c0464eb72b95ec263aa16279be57e67" title="[EPERM] No permission to perform operation">NvSciError_NotPermitted</a> Indicates process doesn't have the required privilege.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Invocation of <a class="el" href="group__nvsci__ipc__event.html#ga9d4082ed65f56a8fc0dcc9f628816818" title="Creates a new event loop service.">NvSciEventLoopServiceCreateSafe()</a> must be successful. Invocation of <a class="el" href="group__nvsci__ipc__api.html#ga9d1e5e9447b89ea626616fdf7d2dbe91" title="Initializes the NvSciIpc library.">NvSciIpcInit()</a> must be successful.</dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: Yes</li>
<li>Async/Sync: Sync</li>
</ul>
</li>
<li>Required Privileges(QNX): PROCMGR_AID_MEM_PHYS, "NvSciIpcEndpoint"</li>
<li>API Group<ul>
<li>Init: Yes</li>
<li>Runtime: No</li>
<li>De-Init: No </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="ga0eabb25c5ac0457990a2a7535ef0e870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0eabb25c5ac0457990a2a7535ef0e870">&#9670;&nbsp;</a></span>NvSciIpcRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938">NvSciError</a> NvSciIpcRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvsci__ipc__api.html#ga59ade49463d6ce5b5ee2cc20f9cbab92">NvSciIpcEndpoint</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the contents of the next frame from an endpoint. </p>
<dl class="section warning"><dt>Warning</dt><dd>This API will be deprecated in future release. Use <a class="el" href="group__nvsci__ipc__api.html#ga63bb5b3fe6f72bb793043cac78af60fd" title="Returns the contents of the next frame from an endpoint.">NvSciIpcReadSafe()</a> instead of this.</dd></dl>
<p>This function removes the next frame and copies its contents into a buffer. If the destination buffer is smaller than the configured frame size of the endpoint, the trailing bytes are discarded.</p>
<p>This is a non-blocking call. Read channel of the endpoint must not be empty. If read channel of the endpoint was previously full, then the function notifies the remote endpoint.</p>
<p>This operation cannot proceed if the endpoint is being reset. However, if the remote endpoint has called <a class="el" href="group__nvsci__ipc__api.html#ga93831442d2f06ef6ec4787bf6ec76c7c" title="Resets an endpoint.">NvSciIpcResetEndpointSafe()</a>, calls to this function can still succeed until the next event notification on the local endpoint.</p>
<p>The user shall make sure if actual input buffer size is equal or bigger than requested size before using this API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The handle to the endpoint to read from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>A pointer to a destination buffer to receive the contents of the next frame. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of bytes to copy from the frame, not to exceed the length of the destination buffer and configured frame size of the endpoint. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bytes</td><td>The number of bytes read on success.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938" title="Return/error codes for all NvSci functions.">NvSciError</a>, the completion code of the operation:<ul>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938ae40bf61f6e341173fd828847232228f7" title="[EOK] No error">NvSciError_Success</a> Indicates a successful operation.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a544a45defff9378e5cf10fc67d05eaf9" title="[EINVAL] Invalid parameter value">NvSciError_BadParameter</a> Indicates an invalid <em>handle</em> or <em>size</em>.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a4c7e4f51a82124c413388e723da685b9" title="Required resource is not initialized.">NvSciError_NotInitialized</a> Indicates NvSciIpc is uninitialized.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a41e2e6fb319c3d8154c3e7c84f34138a" title="[ENOMEM] Not enough memory">NvSciError_InsufficientMemory</a> Indicates read channel is empty and the read operation aborted.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a42af452ead371bceb72f99d3d7527fe2" title="[ECONNRESET] Connection was closed or lost">NvSciError_ConnectionReset</a> Indicates the endpoint is being reset.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a075b2f546b586c49a99b681bb751a53a" title="[ENOTSUP] Feature is not supported">NvSciError_NotSupported</a> Indicates API is not supported on provided endpoint backend type.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a9ae3de2bb86075c82b9c249152863749" title="Resource is in wrong state to perform operation.">NvSciError_InvalidState</a> Indicates an invalid operation state.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="group__nvsci__ipc__api.html#ga93831442d2f06ef6ec4787bf6ec76c7c" title="Resets an endpoint.">NvSciIpcResetEndpointSafe()</a> must be successful.</dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: Yes</li>
<li>Async/Sync: Sync</li>
</ul>
</li>
<li>Required Privileges(QNX): None</li>
<li>API Group<ul>
<li>Init: No</li>
<li>Runtime: Yes</li>
<li>De-Init: No </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="ga80fcfa1951449da7c5f7bd6f46666cc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80fcfa1951449da7c5f7bd6f46666cc8">&#9670;&nbsp;</a></span>NvSciIpcReadAdvance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938">NvSciError</a> NvSciIpcReadAdvance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvsci__ipc__api.html#ga59ade49463d6ce5b5ee2cc20f9cbab92">NvSciIpcEndpoint</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the next frame from an endpoint. </p>
<p>This is a non-blocking call. Read channel of the endpoint must not be empty. If a read channel of the endpoint was previously full, then this function notifies the remote endpoint.</p>
<p>This operation cannot proceed if the endpoint is being reset. However, if the remote endpoint has called <a class="el" href="group__nvsci__ipc__api.html#ga93831442d2f06ef6ec4787bf6ec76c7c" title="Resets an endpoint.">NvSciIpcResetEndpointSafe()</a>, calls to this function can still succeed until the next event notification on the local endpoint.</p>
<p>Between <a class="el" href="group__nvsci__ipc__api.html#ga0fbf020d67a2d5e53187eb7173a0514f" title="Returns a pointer to the location of the next frame from an endpoint.">NvSciIpcReadGetNextFrame()</a> and <a class="el" href="group__nvsci__ipc__api.html#ga80fcfa1951449da7c5f7bd6f46666cc8" title="Removes the next frame from an endpoint.">NvSciIpcReadAdvance()</a>, do not perform any other NvSciIpc read operations with the same endpoint handle. Once a read frame is released by <a class="el" href="group__nvsci__ipc__api.html#ga80fcfa1951449da7c5f7bd6f46666cc8" title="Removes the next frame from an endpoint.">NvSciIpcReadAdvance()</a>, do not use previously returned pointer of <a class="el" href="group__nvsci__ipc__api.html#ga0fbf020d67a2d5e53187eb7173a0514f" title="Returns a pointer to the location of the next frame from an endpoint.">NvSciIpcReadGetNextFrame()</a> since it is already invalid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The handle to the endpoint to read from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938" title="Return/error codes for all NvSci functions.">NvSciError</a>, the completion code of the operation:<ul>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938ae40bf61f6e341173fd828847232228f7" title="[EOK] No error">NvSciError_Success</a> Indicates the frame was removed successfully.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a544a45defff9378e5cf10fc67d05eaf9" title="[EINVAL] Invalid parameter value">NvSciError_BadParameter</a> Indicates an invalid <em>handle</em>.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a4c7e4f51a82124c413388e723da685b9" title="Required resource is not initialized.">NvSciError_NotInitialized</a> Indicates NvSciIpc is uninitialized.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a41e2e6fb319c3d8154c3e7c84f34138a" title="[ENOMEM] Not enough memory">NvSciError_InsufficientMemory</a> Indicates read channel is empty and the read operation aborted.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a42af452ead371bceb72f99d3d7527fe2" title="[ECONNRESET] Connection was closed or lost">NvSciError_ConnectionReset</a> Indicates the endpoint is being reset.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a075b2f546b586c49a99b681bb751a53a" title="[ENOTSUP] Feature is not supported">NvSciError_NotSupported</a> Indicates API is not supported in provided endpoint backend type.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a9ae3de2bb86075c82b9c249152863749" title="Resource is in wrong state to perform operation.">NvSciError_InvalidState</a> Indicates an invalid operation state.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="group__nvsci__ipc__api.html#ga93831442d2f06ef6ec4787bf6ec76c7c" title="Resets an endpoint.">NvSciIpcResetEndpointSafe()</a> must be successful.</dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: Yes</li>
<li>Async/Sync: Sync</li>
</ul>
</li>
<li>Required Privileges(QNX): None</li>
<li>API Group<ul>
<li>Init: No</li>
<li>Runtime: Yes</li>
<li>De-Init: No </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="ga0fbf020d67a2d5e53187eb7173a0514f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fbf020d67a2d5e53187eb7173a0514f">&#9670;&nbsp;</a></span>NvSciIpcReadGetNextFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938">NvSciError</a> NvSciIpcReadGetNextFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvsci__ipc__api.html#ga59ade49463d6ce5b5ee2cc20f9cbab92">NvSciIpcEndpoint</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const volatile void **&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the location of the next frame from an endpoint. </p>
<p>This is a non-blocking call. This operation cannot proceed if the endpoint is being reset. However, if the remote endpoint has called <a class="el" href="group__nvsci__ipc__api.html#ga93831442d2f06ef6ec4787bf6ec76c7c" title="Resets an endpoint.">NvSciIpcResetEndpointSafe()</a>, calls to this function can still succeed until the next event notification on the local endpoint. Between <a class="el" href="group__nvsci__ipc__api.html#ga0fbf020d67a2d5e53187eb7173a0514f" title="Returns a pointer to the location of the next frame from an endpoint.">NvSciIpcReadGetNextFrame()</a> and <a class="el" href="group__nvsci__ipc__api.html#ga80fcfa1951449da7c5f7bd6f46666cc8" title="Removes the next frame from an endpoint.">NvSciIpcReadAdvance()</a>, do not perform any other NvSciIpc read operations with the same endpoint handle. Once a read frame is released by <a class="el" href="group__nvsci__ipc__api.html#ga80fcfa1951449da7c5f7bd6f46666cc8" title="Removes the next frame from an endpoint.">NvSciIpcReadAdvance()</a>, do not use previously returned pointer of <a class="el" href="group__nvsci__ipc__api.html#ga0fbf020d67a2d5e53187eb7173a0514f" title="Returns a pointer to the location of the next frame from an endpoint.">NvSciIpcReadGetNextFrame()</a> since it is already invalid. Do not write through a returned pointer of <a class="el" href="group__nvsci__ipc__api.html#ga0fbf020d67a2d5e53187eb7173a0514f" title="Returns a pointer to the location of the next frame from an endpoint.">NvSciIpcReadGetNextFrame()</a>. This is protected by a const volatile pointer return type. Do not read the same memory location multiple times. If required, copy specific memory location to a local buffer before using it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The handle to the endpoint to read from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>A pointer to a destination buffer to receive the contents of the next frame on success.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938" title="Return/error codes for all NvSci functions.">NvSciError</a>, the completion code of the operation:<ul>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938ae40bf61f6e341173fd828847232228f7" title="[EOK] No error">NvSciError_Success</a> Indicates a successful operation.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a544a45defff9378e5cf10fc67d05eaf9" title="[EINVAL] Invalid parameter value">NvSciError_BadParameter</a> Indicates an invalid <em>handle</em>.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a4c7e4f51a82124c413388e723da685b9" title="Required resource is not initialized.">NvSciError_NotInitialized</a> Indicates NvSciIpc is uninitialized.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a41e2e6fb319c3d8154c3e7c84f34138a" title="[ENOMEM] Not enough memory">NvSciError_InsufficientMemory</a> Indicates read channel is empty and the read operation aborted.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a42af452ead371bceb72f99d3d7527fe2" title="[ECONNRESET] Connection was closed or lost">NvSciError_ConnectionReset</a> Indicates the endpoint is being reset.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a075b2f546b586c49a99b681bb751a53a" title="[ENOTSUP] Feature is not supported">NvSciError_NotSupported</a> Indicates API is not supported in provided endpoint backend type.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a9ae3de2bb86075c82b9c249152863749" title="Resource is in wrong state to perform operation.">NvSciError_InvalidState</a> Indicates an invalid operation state.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="group__nvsci__ipc__api.html#ga93831442d2f06ef6ec4787bf6ec76c7c" title="Resets an endpoint.">NvSciIpcResetEndpointSafe()</a> must be successful.</dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: Yes</li>
<li>Async/Sync: Sync</li>
</ul>
</li>
<li>Required Privileges(QNX): None</li>
<li>API Group<ul>
<li>Init: No</li>
<li>Runtime: Yes</li>
<li>De-Init: No </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="ga63bb5b3fe6f72bb793043cac78af60fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63bb5b3fe6f72bb793043cac78af60fd">&#9670;&nbsp;</a></span>NvSciIpcReadSafe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938">NvSciError</a> NvSciIpcReadSafe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvsci__ipc__api.html#ga59ade49463d6ce5b5ee2cc20f9cbab92">NvSciIpcEndpoint</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the contents of the next frame from an endpoint. </p>
<p>(safety version)</p>
<p>This function removes the next frame and copies its contents into a buffer. If the destination buffer is smaller than the configured frame size of the endpoint, the trailing bytes are discarded.</p>
<p>This is a non-blocking call. Read channel of the endpoint must not be empty. If read channel of the endpoint was previously full, then the function notifies the remote endpoint.</p>
<p>This operation cannot proceed if the endpoint is being reset. However, if the remote endpoint has called <a class="el" href="group__nvsci__ipc__api.html#ga93831442d2f06ef6ec4787bf6ec76c7c" title="Resets an endpoint.">NvSciIpcResetEndpointSafe()</a>, calls to this function can still succeed until the next event notification on the local endpoint.</p>
<p>The user shall make sure if actual input buffer size is equal or bigger than requested size before using this API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The handle to the endpoint to read from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>A pointer to a destination buffer to receive the contents of the next frame. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of bytes to copy from the frame, not to exceed the length of the destination buffer and configured frame size of the endpoint. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bytes</td><td>The number of bytes read on success.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938" title="Return/error codes for all NvSci functions.">NvSciError</a>, the completion code of the operation:<ul>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938ae40bf61f6e341173fd828847232228f7" title="[EOK] No error">NvSciError_Success</a> Indicates a successful operation.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a544a45defff9378e5cf10fc67d05eaf9" title="[EINVAL] Invalid parameter value">NvSciError_BadParameter</a> Indicates an invalid <em>handle</em> or <em>size</em>.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a4c7e4f51a82124c413388e723da685b9" title="Required resource is not initialized.">NvSciError_NotInitialized</a> Indicates NvSciIpc is uninitialized.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a41e2e6fb319c3d8154c3e7c84f34138a" title="[ENOMEM] Not enough memory">NvSciError_InsufficientMemory</a> Indicates read channel is empty and the read operation aborted.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a42af452ead371bceb72f99d3d7527fe2" title="[ECONNRESET] Connection was closed or lost">NvSciError_ConnectionReset</a> Indicates the endpoint is being reset.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a075b2f546b586c49a99b681bb751a53a" title="[ENOTSUP] Feature is not supported">NvSciError_NotSupported</a> Indicates API is not supported on provided endpoint backend type.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a9ae3de2bb86075c82b9c249152863749" title="Resource is in wrong state to perform operation.">NvSciError_InvalidState</a> Indicates an invalid operation state.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="group__nvsci__ipc__api.html#ga93831442d2f06ef6ec4787bf6ec76c7c" title="Resets an endpoint.">NvSciIpcResetEndpointSafe()</a> must be successful.</dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: Yes</li>
<li>Async/Sync: Sync</li>
</ul>
</li>
<li>Required Privileges(QNX): None</li>
<li>API Group<ul>
<li>Init: No</li>
<li>Runtime: Yes</li>
<li>De-Init: No </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="gab3dd21216a75c3c14303fd83c968e96a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3dd21216a75c3c14303fd83c968e96a">&#9670;&nbsp;</a></span>NvSciIpcResetEndpoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void NvSciIpcResetEndpoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvsci__ipc__api.html#ga59ade49463d6ce5b5ee2cc20f9cbab92">NvSciIpcEndpoint</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets an endpoint. </p>
<dl class="section warning"><dt>Warning</dt><dd>This API will be deprecated in future release. Use <a class="el" href="group__nvsci__ipc__api.html#ga93831442d2f06ef6ec4787bf6ec76c7c" title="Resets an endpoint.">NvSciIpcResetEndpointSafe()</a> instead of this.</dd></dl>
<p>Initiates a reset on the endpoint and notifies the remote endpoint. Applications must call this function at most once per endpoint handle during Init mode and complete the reset operation before using the endpoint for communication. Once this API is called, all existing data in channel will be discarded. After invoking this function, client user shall call <a class="el" href="group__nvsci__ipc__api.html#gac0c8482abc29cc356f0c73ed0cca1bd4" title="Get Events.">NvSciIpcGetEvent()</a> to get specific event type (READ, WRITE etc.). if desired event is not returned from GetEvent API, OS-specific blocking call (select/poll/epoll or NvSciIpcWaitEventQnx) should be called to wait remote notification. This sequence must be done repeatedly to get event type that endpoint wants. When this function is called during De-Init mode (i.e. synchronization for closing channel), it must be called at most once and <a class="el" href="group__nvsci__ipc__api.html#gac0c8482abc29cc356f0c73ed0cca1bd4" title="Get Events.">NvSciIpcGetEvent()</a> must NOT be called after <a class="el" href="group__nvsci__ipc__api.html#gab3dd21216a75c3c14303fd83c968e96a" title="Resets an endpoint.">NvSciIpcResetEndpoint()</a> is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>A handle to the endpoint to reset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>void</code> </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Invocation of <a class="el" href="group__nvsci__ipc__api.html#ga3acc28ad8a4ebe4d8175c70324424094" title="Opens an endpoint with the given name.">NvSciIpcOpenEndpoint()</a> must be successful.</dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: Yes</li>
<li>Async/Sync: Sync</li>
</ul>
</li>
<li>Required Privileges(QNX): None</li>
<li>API Group<ul>
<li>Init: Yes</li>
<li>Runtime: Yes</li>
<li>De-Init: Yes </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="ga93831442d2f06ef6ec4787bf6ec76c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93831442d2f06ef6ec4787bf6ec76c7c">&#9670;&nbsp;</a></span>NvSciIpcResetEndpointSafe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938">NvSciError</a> NvSciIpcResetEndpointSafe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvsci__ipc__api.html#ga59ade49463d6ce5b5ee2cc20f9cbab92">NvSciIpcEndpoint</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets an endpoint. </p>
<p>(safety version)</p>
<p>Initiates a reset on the endpoint and notifies the remote endpoint. Applications must call this function at most once per endpoint handle during Init mode and complete the reset operation before using the endpoint for communication. Once this API is called, all existing data in channel will be discarded. After invoking this function, client user shall call <a class="el" href="group__nvsci__ipc__api.html#gac0c8482abc29cc356f0c73ed0cca1bd4" title="Get Events.">NvSciIpcGetEvent()</a> to get specific event type (READ, WRITE etc.). if desired event is not returned from GetEvent API, OS-specific blocking call (select/poll/epoll or NvSciIpcWaitEventQnx) should be called to wait remote notification. This sequence must be done repeatedly to get event type that endpoint wants. When this function is called during De-Init mode (i.e. synchronization for closing channel), it must be called at most once and <a class="el" href="group__nvsci__ipc__api.html#gac0c8482abc29cc356f0c73ed0cca1bd4" title="Get Events.">NvSciIpcGetEvent()</a> must NOT be called after <a class="el" href="group__nvsci__ipc__api.html#ga93831442d2f06ef6ec4787bf6ec76c7c" title="Resets an endpoint.">NvSciIpcResetEndpointSafe()</a> is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>A handle to the endpoint to reset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938" title="Return/error codes for all NvSci functions.">NvSciError</a>, the completion code of the operation:<ul>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938ae40bf61f6e341173fd828847232228f7" title="[EOK] No error">NvSciError_Success</a> Indicates a successful operation.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a544a45defff9378e5cf10fc67d05eaf9" title="[EINVAL] Invalid parameter value">NvSciError_BadParameter</a> Indicates an invalid <em>handle</em>.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a4c7e4f51a82124c413388e723da685b9" title="Required resource is not initialized.">NvSciError_NotInitialized</a> Indicates NvSciIpc is uninitialized.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a9ae3de2bb86075c82b9c249152863749" title="Resource is in wrong state to perform operation.">NvSciError_InvalidState</a> Indicates an invalid operation state.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a075b2f546b586c49a99b681bb751a53a" title="[ENOTSUP] Feature is not supported">NvSciError_NotSupported</a> Indicates API is not supported on provided endpoint backend type.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>Invocation of <a class="el" href="group__nvsci__ipc__api.html#ga3acc28ad8a4ebe4d8175c70324424094" title="Opens an endpoint with the given name.">NvSciIpcOpenEndpoint()</a> must be successful.</dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: Yes</li>
<li>Async/Sync: Sync</li>
</ul>
</li>
<li>Required Privileges(QNX): None</li>
<li>API Group<ul>
<li>Init: Yes</li>
<li>Runtime: Yes</li>
<li>De-Init: Yes </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="ga6c0266eb2aaef1ec32ac31a479a6ee23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c0266eb2aaef1ec32ac31a479a6ee23">&#9670;&nbsp;</a></span>NvSciIpcWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938">NvSciError</a> NvSciIpcWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvsci__ipc__api.html#ga59ade49463d6ce5b5ee2cc20f9cbab92">NvSciIpcEndpoint</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a new frame to the endpoint. </p>
<dl class="section warning"><dt>Warning</dt><dd>This API will be deprecated in future release. Use <a class="el" href="group__nvsci__ipc__api.html#ga2eb7f4a5c6e33a641b980ed9c3612cf1" title="Writes a new frame to the endpoint.">NvSciIpcWriteSafe()</a> instead of this.</dd></dl>
<p>If space is available in the endpoint, this function posts a new frame, copying the contents from the provided data buffer. If <em>size</em> is less than the frame size, then the remaining bytes of the frame are undefined.</p>
<p>This is a non-blocking call. If write channel of the endpoint was previously empty, then the function notifies the remote endpoint.</p>
<p>This operation cannot proceed if the endpoint is being reset.</p>
<p>The user shall make sure if actual input buffer size is equal or bigger than requested size before using this API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The handle to the endpoint to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>A pointer to a source buffer for the contents of the next frame. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of bytes to be copied to the frame, not to exceed the length of the destination buffer and configured frame size of the endpoint. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bytes</td><td>The number of bytes written on success.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938" title="Return/error codes for all NvSci functions.">NvSciError</a>, the completion code of the operation:<ul>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938ae40bf61f6e341173fd828847232228f7" title="[EOK] No error">NvSciError_Success</a> Indicates a successful operation.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a544a45defff9378e5cf10fc67d05eaf9" title="[EINVAL] Invalid parameter value">NvSciError_BadParameter</a> Indicates an invalid <em>handle</em> or <em>size</em>.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a4c7e4f51a82124c413388e723da685b9" title="Required resource is not initialized.">NvSciError_NotInitialized</a> Indicates NvSciIpc is uninitialized.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a41e2e6fb319c3d8154c3e7c84f34138a" title="[ENOMEM] Not enough memory">NvSciError_InsufficientMemory</a> Indicates write channel is full and the write operation aborted.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a42af452ead371bceb72f99d3d7527fe2" title="[ECONNRESET] Connection was closed or lost">NvSciError_ConnectionReset</a> Indicates the endpoint is being reset.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a075b2f546b586c49a99b681bb751a53a" title="[ENOTSUP] Feature is not supported">NvSciError_NotSupported</a> Indicates API is not supported in provided endpoint backend type.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a9ae3de2bb86075c82b9c249152863749" title="Resource is in wrong state to perform operation.">NvSciError_InvalidState</a> Indicates an invalid operation state.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="group__nvsci__ipc__api.html#ga93831442d2f06ef6ec4787bf6ec76c7c" title="Resets an endpoint.">NvSciIpcResetEndpointSafe()</a> must be successful.</dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: Yes</li>
<li>Async/Sync: Sync</li>
</ul>
</li>
<li>Required Privileges(QNX): None</li>
<li>API Group<ul>
<li>Init: No</li>
<li>Runtime: Yes</li>
<li>De-Init: No </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="ga338f05ed740e1ad33895469d8fa1bfdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga338f05ed740e1ad33895469d8fa1bfdc">&#9670;&nbsp;</a></span>NvSciIpcWriteAdvance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938">NvSciError</a> NvSciIpcWriteAdvance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvsci__ipc__api.html#ga59ade49463d6ce5b5ee2cc20f9cbab92">NvSciIpcEndpoint</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the next frame to the endpoint. </p>
<p>This is a non-blocking call. If write channel of the endpoint is not full, then post the next frame. If write channel of the endpoint was previously empty, then this function notifies the remote endpoint.</p>
<p>This operation cannot proceed if the endpoint is being reset. However, if the remote endpoint has called <a class="el" href="group__nvsci__ipc__api.html#ga93831442d2f06ef6ec4787bf6ec76c7c" title="Resets an endpoint.">NvSciIpcResetEndpointSafe()</a>, calls to this function can still succeed until the next event notification on the local endpoint.</p>
<p>Between <a class="el" href="group__nvsci__ipc__api.html#ga2bc9654b0fa45c253b5cdfed4febda5d" title="Returns a pointer to the location of the next frame for writing data.">NvSciIpcWriteGetNextFrame()</a> and <a class="el" href="group__nvsci__ipc__api.html#ga338f05ed740e1ad33895469d8fa1bfdc" title="Writes the next frame to the endpoint.">NvSciIpcWriteAdvance()</a>, do not perform any other NvSciIpc write operations with the same endpoint handle. Once transmit message is committed by <a class="el" href="group__nvsci__ipc__api.html#ga338f05ed740e1ad33895469d8fa1bfdc" title="Writes the next frame to the endpoint.">NvSciIpcWriteAdvance()</a>, do not use previously returned pointer of <a class="el" href="group__nvsci__ipc__api.html#ga2bc9654b0fa45c253b5cdfed4febda5d" title="Returns a pointer to the location of the next frame for writing data.">NvSciIpcWriteGetNextFrame()</a> since it is already invalid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The handle to the endpoint to write to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938" title="Return/error codes for all NvSci functions.">NvSciError</a>, the completion code of the operation:<ul>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938ae40bf61f6e341173fd828847232228f7" title="[EOK] No error">NvSciError_Success</a> Indicates successful operation.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a544a45defff9378e5cf10fc67d05eaf9" title="[EINVAL] Invalid parameter value">NvSciError_BadParameter</a> Indicates an invalid <em>handle</em>.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a4c7e4f51a82124c413388e723da685b9" title="Required resource is not initialized.">NvSciError_NotInitialized</a> Indicates NvSciIpc is uninitialized.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a41e2e6fb319c3d8154c3e7c84f34138a" title="[ENOMEM] Not enough memory">NvSciError_InsufficientMemory</a> Indicates write channel is full and the write operation aborted.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a42af452ead371bceb72f99d3d7527fe2" title="[ECONNRESET] Connection was closed or lost">NvSciError_ConnectionReset</a> Indicates the endpoint is being reset.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a075b2f546b586c49a99b681bb751a53a" title="[ENOTSUP] Feature is not supported">NvSciError_NotSupported</a> Indicates API is not supported in provided endpoint backend type.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a9ae3de2bb86075c82b9c249152863749" title="Resource is in wrong state to perform operation.">NvSciError_InvalidState</a> Indicates an invalid operation state.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="group__nvsci__ipc__api.html#ga93831442d2f06ef6ec4787bf6ec76c7c" title="Resets an endpoint.">NvSciIpcResetEndpointSafe()</a> must be successful.</dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: Yes</li>
<li>Async/Sync: Sync</li>
</ul>
</li>
<li>Required Privileges(QNX): None</li>
<li>API Group<ul>
<li>Init: No</li>
<li>Runtime: Yes</li>
<li>De-Init: No </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="ga2bc9654b0fa45c253b5cdfed4febda5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bc9654b0fa45c253b5cdfed4febda5d">&#9670;&nbsp;</a></span>NvSciIpcWriteGetNextFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938">NvSciError</a> NvSciIpcWriteGetNextFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvsci__ipc__api.html#ga59ade49463d6ce5b5ee2cc20f9cbab92">NvSciIpcEndpoint</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">volatile void **&#160;</td>
          <td class="paramname"><em>buf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the location of the next frame for writing data. </p>
<p>This is a non-blocking call. write channel of the endpoint must not be full.</p>
<p>This operation cannot proceed if the endpoint is being reset. However, if the remote endpoint has called <a class="el" href="group__nvsci__ipc__api.html#ga93831442d2f06ef6ec4787bf6ec76c7c" title="Resets an endpoint.">NvSciIpcResetEndpointSafe()</a>, calls to this function can still succeed until the next event notification on the local endpoint. Between <a class="el" href="group__nvsci__ipc__api.html#ga2bc9654b0fa45c253b5cdfed4febda5d" title="Returns a pointer to the location of the next frame for writing data.">NvSciIpcWriteGetNextFrame()</a> and <a class="el" href="group__nvsci__ipc__api.html#ga338f05ed740e1ad33895469d8fa1bfdc" title="Writes the next frame to the endpoint.">NvSciIpcWriteAdvance()</a>, do not perform any other NvSciIpc write operations with the same endpoint handle. Once a transmit message is committed by <a class="el" href="group__nvsci__ipc__api.html#ga338f05ed740e1ad33895469d8fa1bfdc" title="Writes the next frame to the endpoint.">NvSciIpcWriteAdvance()</a>, do not use previously returned pointer of <a class="el" href="group__nvsci__ipc__api.html#ga2bc9654b0fa45c253b5cdfed4febda5d" title="Returns a pointer to the location of the next frame for writing data.">NvSciIpcWriteGetNextFrame()</a> since it is already invalid. Do not read through a returned pointer of <a class="el" href="group__nvsci__ipc__api.html#ga2bc9654b0fa45c253b5cdfed4febda5d" title="Returns a pointer to the location of the next frame for writing data.">NvSciIpcWriteGetNextFrame()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The handle to the endpoint to write to. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>A pointer to a destination buffer to hold the contents of the next frame on success.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938" title="Return/error codes for all NvSci functions.">NvSciError</a>, the completion code of the operation:<ul>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938ae40bf61f6e341173fd828847232228f7" title="[EOK] No error">NvSciError_Success</a> Indicates successful operation.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a544a45defff9378e5cf10fc67d05eaf9" title="[EINVAL] Invalid parameter value">NvSciError_BadParameter</a> Indicates an invalid <em>handle</em>.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a4c7e4f51a82124c413388e723da685b9" title="Required resource is not initialized.">NvSciError_NotInitialized</a> Indicates NvSciIpc is uninitialized.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a41e2e6fb319c3d8154c3e7c84f34138a" title="[ENOMEM] Not enough memory">NvSciError_InsufficientMemory</a> Indicates write channel is full and the write operation aborted.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a42af452ead371bceb72f99d3d7527fe2" title="[ECONNRESET] Connection was closed or lost">NvSciError_ConnectionReset</a> Indicates the endpoint is being reset.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a075b2f546b586c49a99b681bb751a53a" title="[ENOTSUP] Feature is not supported">NvSciError_NotSupported</a> Indicates API is not supported in provided endpoint backend type.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a9ae3de2bb86075c82b9c249152863749" title="Resource is in wrong state to perform operation.">NvSciError_InvalidState</a> Indicates an invalid operation state.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="group__nvsci__ipc__api.html#ga93831442d2f06ef6ec4787bf6ec76c7c" title="Resets an endpoint.">NvSciIpcResetEndpointSafe()</a> must be successful.</dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: Yes</li>
<li>Async/Sync: Sync</li>
</ul>
</li>
<li>Required Privileges(QNX): None</li>
<li>API Group<ul>
<li>Init: No</li>
<li>Runtime: Yes</li>
<li>De-Init: No </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="ga2eb7f4a5c6e33a641b980ed9c3612cf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2eb7f4a5c6e33a641b980ed9c3612cf1">&#9670;&nbsp;</a></span>NvSciIpcWriteSafe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938">NvSciError</a> NvSciIpcWriteSafe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nvsci__ipc__api.html#ga59ade49463d6ce5b5ee2cc20f9cbab92">NvSciIpcEndpoint</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a new frame to the endpoint. </p>
<p>(safety version)</p>
<p>If space is available in the endpoint, this function posts a new frame, copying the contents from the provided data buffer. If <em>size</em> is less than the frame size, then the remaining bytes of the frame are undefined.</p>
<p>This is a non-blocking call. If write channel of the endpoint was previously empty, then the function notifies the remote endpoint.</p>
<p>This operation cannot proceed if the endpoint is being reset.</p>
<p>The user shall make sure if actual input buffer size is equal or bigger than requested size before using this API.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The handle to the endpoint to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>A pointer to a source buffer for the contents of the next frame. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of bytes to be copied to the frame, not to exceed the length of the destination buffer and configured frame size of the endpoint. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bytes</td><td>The number of bytes written on success.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__NvSciError.html#gaef993f18ba16be8c8554d9d8538c5938" title="Return/error codes for all NvSci functions.">NvSciError</a>, the completion code of the operation:<ul>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938ae40bf61f6e341173fd828847232228f7" title="[EOK] No error">NvSciError_Success</a> Indicates a successful operation.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a544a45defff9378e5cf10fc67d05eaf9" title="[EINVAL] Invalid parameter value">NvSciError_BadParameter</a> Indicates an invalid <em>handle</em> or <em>size</em>.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a4c7e4f51a82124c413388e723da685b9" title="Required resource is not initialized.">NvSciError_NotInitialized</a> Indicates NvSciIpc is uninitialized.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a41e2e6fb319c3d8154c3e7c84f34138a" title="[ENOMEM] Not enough memory">NvSciError_InsufficientMemory</a> Indicates write channel is full and the write operation aborted.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a42af452ead371bceb72f99d3d7527fe2" title="[ECONNRESET] Connection was closed or lost">NvSciError_ConnectionReset</a> Indicates the endpoint is being reset.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a075b2f546b586c49a99b681bb751a53a" title="[ENOTSUP] Feature is not supported">NvSciError_NotSupported</a> Indicates API is not supported in provided endpoint backend type.</li>
<li><a class="el" href="group__NvSciError.html#ggaef993f18ba16be8c8554d9d8538c5938a9ae3de2bb86075c82b9c249152863749" title="Resource is in wrong state to perform operation.">NvSciError_InvalidState</a> Indicates an invalid operation state.</li>
</ul>
</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="group__nvsci__ipc__api.html#ga93831442d2f06ef6ec4787bf6ec76c7c" title="Resets an endpoint.">NvSciIpcResetEndpointSafe()</a> must be successful.</dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: Yes</li>
<li>Async/Sync: Sync</li>
</ul>
</li>
<li>Required Privileges(QNX): None</li>
<li>API Group<ul>
<li>Init: No</li>
<li>Runtime: Yes</li>
<li>De-Init: No </li>
</ul>
</li>
</ul>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="agroup__nvsci__ipc__api_html_gaa9e1641c08767a047b6de58114a13bac"><div class="ttname"><a href="group__nvsci__ipc__api.html#gaa9e1641c08767a047b6de58114a13bac">NV_SCI_IPC_EVENT_WRITE_EMPTY</a></div><div class="ttdeci">#define NV_SCI_IPC_EVENT_WRITE_EMPTY</div><div class="ttdoc">Specifies the IPC write fifo empty event.</div><div class="ttdef"><b>Definition:</b> <a href="nvsciipc_8h_source.html#l00314">nvsciipc.h:314</a></div></div>
<div class="ttc" id="agroup__nvsci__ipc__api_html_gabe55c85ed8467eca67b13795d001b02e"><div class="ttname"><a href="group__nvsci__ipc__api.html#gabe55c85ed8467eca67b13795d001b02e">NV_SCI_IPC_EVENT_CONN_EST</a></div><div class="ttdeci">#define NV_SCI_IPC_EVENT_CONN_EST</div><div class="ttdoc">Specifies the IPC connection established event.</div><div class="ttdef"><b>Definition:</b> <a href="nvsciipc_8h_source.html#l00310">nvsciipc.h:310</a></div></div>
<div class="ttc" id="agroup__nvsci__ipc__api_html_gac0c8482abc29cc356f0c73ed0cca1bd4"><div class="ttname"><a href="group__nvsci__ipc__api.html#gac0c8482abc29cc356f0c73ed0cca1bd4">NvSciIpcGetEvent</a></div><div class="ttdeci">NvSciError NvSciIpcGetEvent(NvSciIpcEndpoint handle, uint32_t *events)</div><div class="ttdoc">Get Events.</div></div>
<div class="ttc" id="agroup__nvsci__ipc__api_html_ga10730765f6c4abaaf38e147f7087e029"><div class="ttname"><a href="group__nvsci__ipc__api.html#ga10730765f6c4abaaf38e147f7087e029">NV_SCI_IPC_EVENT_CONN_EST_ALL</a></div><div class="ttdeci">#define NV_SCI_IPC_EVENT_CONN_EST_ALL</div><div class="ttdoc">Specifies single event mask to check IPC connection establishment.</div><div class="ttdef"><b>Definition:</b> <a href="nvsciipc_8h_source.html#l00316">nvsciipc.h:316</a></div></div>
<!--
# Copyright (c) 2022, NVIDIA CORPORATION. All rights reserved.
#
# NVIDIA CORPORATION and its licensors retain all intellectual property
# and proprietary rights in and to this software, related documentation
# and any modifications thereto.  Any use, reproduction, disclosure or
# distribution of this software and related documentation without an express
# license agreement from NVIDIA CORPORATION is strictly prohibited.
-->
  <div id="nav-path" class="navpath">
    <ul>
      <li class="footer footer-left">
        Subject to Change | For test and development only. <br/>
        © 2022 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
      </li>
      <li class="footer">
        Tue Nov 29 2022 20:35:29 |
        PR-10720-6.0
      </li>
      </li>
     </ul>
  </div>
<script type="text/javascript">if (typeof _satellite != "undefined"){ _satellite.pageBottom();}</script>
</body>
</html>
