<!-- HTML header for doxygen 1.8.17-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<!--
 * Copyright (c) 2009-2021 NVIDIA CORPORATION.  All rights reserved.
 *
 * NVIDIA Corporation and its licensors retain all intellectual property
 * and proprietary rights in and to this software, related documentation
 * and any modifications thereto.  Any use, reproduction, disclosure or
 * distribution of this software and related documentation without an express
 * license agreement from NVIDIA Corporation is strictly prohibited.
-->
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NVIDIA DRIVE OS Linux SDK API Reference: nvsipl::INvSIPLCamera Class Reference | NVIDIA Docs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="reverb-search.js"></script>
<script src="//assets.adobedtm.com/5d4962a43b79/c1061d2c5e7b/launch-191c2462b890.min.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="nv_theme_dark.css" rel="stylesheet" type="text/css"/>
<style>
    body {
        background-position: 350px 200px;
        background-image: url(watermark.png);
        background-repeat: no-repeat;
        background-attachment: fixed;
    }
    @media (min-width: 320px) and (max-width: 480px) {
        body { background-position: 55px 350px; }
    }
    @media (min-width: 768px) and (max-width: 1024px) {
        body { background-position: 55px 200px; }
    }
    @media (min-width: 768px) and (max-width: 1024px) and (orientation: landscape) {
        body { background-position: 55px 200px; }
    }
</style>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tbody>
    <tr>
      <td>
      <div>
            <a id="nv-logo" href="https://www.nvidia.com/"></a>
        </div>
        <!--img src="./NVLogo_2D_H.jpg" width="110" height="44"-->
      </td>
    </tr>
    <tr id="titlearea" valign="middle">
        <td width="40%">
            <h1 style="margin-left:12px; margin-top: 10px; margin-bottom:12px;">NVIDIA DRIVE OS Linux SDK API Reference</h1>
        </td>
        <td>
            <h5 style="text-align:right; margin-top: 10px; margin-bottom:12px;">
                6.0.5 Release
            </h5>
        </td>
    </tr>
  </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classnvsipl_1_1INvSIPLCamera.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">nvsipl::INvSIPLCamera Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The top-level API for SIPL. </p>
<p>A SIPL client acquires this API by calling <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#a11634bf312e15a083d45f92ed8791b04" title="Get a handle to an INvSIPLCamera instance.">GetInstance()</a> exactly once. </p>

<p class="definition">Definition at line <a class="el" href="NvSIPLCamera_8hpp_source.html#l00158">158</a> of file <a class="el" href="NvSIPLCamera_8hpp_source.html">NvSIPLCamera.hpp</a>.</p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a87e541fb56092ed4f3a6ab81fe7ef995"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvsipl_1_1INvSIPLCamera.html#a87e541fb56092ed4f3a6ab81fe7ef995">SetPlatformCfg</a> (<a class="el" href="structnvsipl_1_1PlatformCfg.html">PlatformCfg</a> const *const platformConfig)=0</td></tr>
<tr class="memdesc:a87e541fb56092ed4f3a6ab81fe7ef995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a platform configuration.  <a href="classnvsipl_1_1INvSIPLCamera.html#a87e541fb56092ed4f3a6ab81fe7ef995">More...</a><br /></td></tr>
<tr class="separator:a87e541fb56092ed4f3a6ab81fe7ef995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3bb6c78f7251ee5666621309adde0d4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvsipl_1_1INvSIPLCamera.html#ac3bb6c78f7251ee5666621309adde0d4">SetPlatformCfg</a> (<a class="el" href="structnvsipl_1_1PlatformCfg.html">PlatformCfg</a> const *const platformConfig, <a class="el" href="structnvsipl_1_1NvSIPLDeviceBlockQueues.html">NvSIPLDeviceBlockQueues</a> &amp;queues)=0</td></tr>
<tr class="memdesc:ac3bb6c78f7251ee5666621309adde0d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a platform configuration and returns the device block notification queues.  <a href="classnvsipl_1_1INvSIPLCamera.html#ac3bb6c78f7251ee5666621309adde0d4">More...</a><br /></td></tr>
<tr class="separator:ac3bb6c78f7251ee5666621309adde0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8908aaf6991482b0a67ce2684234e6e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvsipl_1_1INvSIPLCamera.html#ab8908aaf6991482b0a67ce2684234e6e">SetPipelineCfg</a> (uint32_t index, <a class="el" href="structnvsipl_1_1NvSIPLPipelineConfiguration.html">NvSIPLPipelineConfiguration</a> const &amp;pipelineCfg, <a class="el" href="structnvsipl_1_1NvSIPLPipelineQueues.html">NvSIPLPipelineQueues</a> &amp;queues)=0</td></tr>
<tr class="memdesc:ab8908aaf6991482b0a67ce2684234e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a pipeline configuration.  <a href="classnvsipl_1_1INvSIPLCamera.html#ab8908aaf6991482b0a67ce2684234e6e">More...</a><br /></td></tr>
<tr class="separator:ab8908aaf6991482b0a67ce2684234e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba89991ad75bef5b9abf95002c5adcf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvsipl_1_1INvSIPLCamera.html#aaba89991ad75bef5b9abf95002c5adcf">RegisterAutoControlPlugin</a> (uint32_t index, <a class="el" href="group__NvSIPLAutoControl.html#ga5d84afd445c05b3e5aa836ae436ea454">PluginType</a> type, <a class="el" href="classnvsipl_1_1ISiplControlAuto.html">ISiplControlAuto</a> *const autoControl, std::vector&lt; uint8_t &gt; const &amp;blob)=0</td></tr>
<tr class="memdesc:aaba89991ad75bef5b9abf95002c5adcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register the Auto Control plugin to be used for a specific pipeline.  <a href="classnvsipl_1_1INvSIPLCamera.html#aaba89991ad75bef5b9abf95002c5adcf">More...</a><br /></td></tr>
<tr class="separator:aaba89991ad75bef5b9abf95002c5adcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea69c4c93f839ce6b86420b7cdb8ad0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvsipl_1_1INvSIPLCamera.html#a5ea69c4c93f839ce6b86420b7cdb8ad0">Init</a> ()=0</td></tr>
<tr class="memdesc:a5ea69c4c93f839ce6b86420b7cdb8ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the API for the selected platform configuration.  <a href="classnvsipl_1_1INvSIPLCamera.html#a5ea69c4c93f839ce6b86420b7cdb8ad0">More...</a><br /></td></tr>
<tr class="separator:a5ea69c4c93f839ce6b86420b7cdb8ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21de1ff999eb8962f7a69cbf358a4a3d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvsipl_1_1INvSIPLCamera.html#a21de1ff999eb8962f7a69cbf358a4a3d">SetSensorCharMode</a> (uint32_t index, uint8_t expNo)=0</td></tr>
<tr class="memdesc:a21de1ff999eb8962f7a69cbf358a4a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set sensor in characterization mode.  <a href="classnvsipl_1_1INvSIPLCamera.html#a21de1ff999eb8962f7a69cbf358a4a3d">More...</a><br /></td></tr>
<tr class="separator:a21de1ff999eb8962f7a69cbf358a4a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a800f20b2abb58897aa3c672e61bf5874"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvsipl_1_1INvSIPLCamera.html#a800f20b2abb58897aa3c672e61bf5874">GetImageAttributes</a> (uint32_t index, <a class="el" href="structnvsipl_1_1INvSIPLClient_1_1ConsumerDesc.html#a95eeca9f6deb4f6114d76c9e6ec25aac">INvSIPLClient::ConsumerDesc::OutputType</a> const outType, <a class="el" href="group__nvscibuf__attr__datastructures.html#ga45b3b5302a7d48333f3c03cc8d49a020">NvSciBufAttrList</a> &amp;imageAttr)=0</td></tr>
<tr class="memdesc:a800f20b2abb58897aa3c672e61bf5874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get image attributes.  <a href="classnvsipl_1_1INvSIPLCamera.html#a800f20b2abb58897aa3c672e61bf5874">More...</a><br /></td></tr>
<tr class="separator:a800f20b2abb58897aa3c672e61bf5874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e21ab1bbd3faca3dd46f7fc8a2af7f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvsipl_1_1INvSIPLCamera.html#a34e21ab1bbd3faca3dd46f7fc8a2af7f">ReadEEPROMData</a> (uint32_t const index, uint16_t const address, uint32_t const length, uint8_t *const buffer)=0</td></tr>
<tr class="memdesc:a34e21ab1bbd3faca3dd46f7fc8a2af7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from an EEPROM in a camera module.  <a href="classnvsipl_1_1INvSIPLCamera.html#a34e21ab1bbd3faca3dd46f7fc8a2af7f">More...</a><br /></td></tr>
<tr class="separator:a34e21ab1bbd3faca3dd46f7fc8a2af7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb039b78b216013784654985346af728"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvsipl_1_1INvSIPLCamera.html#aeb039b78b216013784654985346af728">RegisterImages</a> (uint32_t const index, <a class="el" href="structnvsipl_1_1INvSIPLClient_1_1ConsumerDesc.html#a95eeca9f6deb4f6114d76c9e6ec25aac">INvSIPLClient::ConsumerDesc::OutputType</a> const outType, std::vector&lt; <a class="el" href="group__nvscibuf__attr__datastructures.html#ga64cc45c7902fc2498c079097942e875b">NvSciBufObj</a> &gt; const &amp;images)=0</td></tr>
<tr class="memdesc:aeb039b78b216013784654985346af728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register images.  <a href="classnvsipl_1_1INvSIPLCamera.html#aeb039b78b216013784654985346af728">More...</a><br /></td></tr>
<tr class="separator:aeb039b78b216013784654985346af728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae265de46988e46f2719b0c075e721e19"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvsipl_1_1INvSIPLCamera.html#ae265de46988e46f2719b0c075e721e19">Start</a> ()=0</td></tr>
<tr class="memdesc:ae265de46988e46f2719b0c075e721e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Begin streaming from all sensors in the selected platform configuration.  <a href="classnvsipl_1_1INvSIPLCamera.html#ae265de46988e46f2719b0c075e721e19">More...</a><br /></td></tr>
<tr class="separator:ae265de46988e46f2719b0c075e721e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4abc9d68fe563d07ad612b5c421da801"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvsipl_1_1INvSIPLCamera.html#a4abc9d68fe563d07ad612b5c421da801">Stop</a> ()=0</td></tr>
<tr class="memdesc:a4abc9d68fe563d07ad612b5c421da801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop streaming from all sensors in the selected platform configuration.  <a href="classnvsipl_1_1INvSIPLCamera.html#a4abc9d68fe563d07ad612b5c421da801">More...</a><br /></td></tr>
<tr class="separator:a4abc9d68fe563d07ad612b5c421da801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3d0798198a31e1a7921c83ff5af3d0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvsipl_1_1INvSIPLCamera.html#aff3d0798198a31e1a7921c83ff5af3d0">Deinit</a> ()=0</td></tr>
<tr class="memdesc:aff3d0798198a31e1a7921c83ff5af3d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deinitialize the API for the selected platform configuration.  <a href="classnvsipl_1_1INvSIPLCamera.html#aff3d0798198a31e1a7921c83ff5af3d0">More...</a><br /></td></tr>
<tr class="separator:aff3d0798198a31e1a7921c83ff5af3d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f141ec53d5c3b165ae7dacb9e4341f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvsipl_1_1INvSIPLCamera.html#a28f141ec53d5c3b165ae7dacb9e4341f">GetMaxErrorSize</a> (uint32_t const devBlkIndex, size_t &amp;maxErrorSize)=0</td></tr>
<tr class="memdesc:a28f141ec53d5c3b165ae7dacb9e4341f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximum size of error information.  <a href="classnvsipl_1_1INvSIPLCamera.html#a28f141ec53d5c3b165ae7dacb9e4341f">More...</a><br /></td></tr>
<tr class="separator:a28f141ec53d5c3b165ae7dacb9e4341f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8931f2b886c136cb8d18bf0d07080e2b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvsipl_1_1INvSIPLCamera.html#a8931f2b886c136cb8d18bf0d07080e2b">GetErrorGPIOEventInfo</a> (uint32_t const devBlkIndex, uint32_t const gpioIndex, <a class="el" href="group__NvSIPL.html#ga46665f08a63d55add49961ae3abbf9d4">SIPLGpioEvent</a> &amp;event)=0</td></tr>
<tr class="memdesc:a8931f2b886c136cb8d18bf0d07080e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the error interrupt event information for a GPIO activation.  <a href="classnvsipl_1_1INvSIPLCamera.html#a8931f2b886c136cb8d18bf0d07080e2b">More...</a><br /></td></tr>
<tr class="separator:a8931f2b886c136cb8d18bf0d07080e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa56c624e006571585cd3703477581d7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvsipl_1_1INvSIPLCamera.html#afa56c624e006571585cd3703477581d7">GetDeserializerErrorInfo</a> (uint32_t const devBlkIndex, <a class="el" href="structnvsipl_1_1SIPLErrorDetails.html">SIPLErrorDetails</a> *const deserializerErrorInfo, bool &amp;isRemoteError, uint8_t &amp;linkErrorMask)=0</td></tr>
<tr class="memdesc:afa56c624e006571585cd3703477581d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get generic deserializer error information.  <a href="classnvsipl_1_1INvSIPLCamera.html#afa56c624e006571585cd3703477581d7">More...</a><br /></td></tr>
<tr class="separator:afa56c624e006571585cd3703477581d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac068d23caf12c4f815c0601aec944257"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvsipl_1_1INvSIPLCamera.html#ac068d23caf12c4f815c0601aec944257">GetModuleErrorInfo</a> (uint32_t const index, <a class="el" href="structnvsipl_1_1SIPLErrorDetails.html">SIPLErrorDetails</a> *const serializerErrorInfo, <a class="el" href="structnvsipl_1_1SIPLErrorDetails.html">SIPLErrorDetails</a> *const sensorErrorInfo, <a class="el" href="group__NvSIPL.html#ga28a556387b46941209b9ee75065a950f">SIPLModuleErrorReadFlag</a> const errorsToRead=<a class="el" href="group__NvSIPL.html#gga28a556387b46941209b9ee75065a950fa97170f0579dccf4daedd39f92c70b6a7">NVSIPL_MODULE_ERROR_READ_ALL</a>)=0</td></tr>
<tr class="memdesc:ac068d23caf12c4f815c0601aec944257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets generic module error information.  <a href="classnvsipl_1_1INvSIPLCamera.html#ac068d23caf12c4f815c0601aec944257">More...</a><br /></td></tr>
<tr class="separator:ac068d23caf12c4f815c0601aec944257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1e11396f0f08f226b9c13336d513b89"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvsipl_1_1INvSIPLCamera.html#ab1e11396f0f08f226b9c13336d513b89">DisableLink</a> (uint32_t index)=0</td></tr>
<tr class="memdesc:ab1e11396f0f08f226b9c13336d513b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable a given link.  <a href="classnvsipl_1_1INvSIPLCamera.html#ab1e11396f0f08f226b9c13336d513b89">More...</a><br /></td></tr>
<tr class="separator:ab1e11396f0f08f226b9c13336d513b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05ba09cd61305ae62671a7e0533e7fd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvsipl_1_1INvSIPLCamera.html#ad05ba09cd61305ae62671a7e0533e7fd">EnableLink</a> (uint32_t index, bool const resetModule)=0</td></tr>
<tr class="memdesc:ad05ba09cd61305ae62671a7e0533e7fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable a given link.  <a href="classnvsipl_1_1INvSIPLCamera.html#ad05ba09cd61305ae62671a7e0533e7fd">More...</a><br /></td></tr>
<tr class="separator:ad05ba09cd61305ae62671a7e0533e7fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba0a26f4e1d3ebe8b105bddfc370480"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvsipl_1_1INvSIPLCamera.html#a9ba0a26f4e1d3ebe8b105bddfc370480">ToggleLED</a> (uint32_t index, bool enable)=0</td></tr>
<tr class="memdesc:a9ba0a26f4e1d3ebe8b105bddfc370480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control the LED on the associated camera module.  <a href="classnvsipl_1_1INvSIPLCamera.html#a9ba0a26f4e1d3ebe8b105bddfc370480">More...</a><br /></td></tr>
<tr class="separator:a9ba0a26f4e1d3ebe8b105bddfc370480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b8c6194383b6116eb78f307a7698ec"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvsipl_1_1INvSIPLCamera.html#a17b8c6194383b6116eb78f307a7698ec">~INvSIPLCamera</a> ()=default</td></tr>
<tr class="memdesc:a17b8c6194383b6116eb78f307a7698ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor.  <a href="classnvsipl_1_1INvSIPLCamera.html#a17b8c6194383b6116eb78f307a7698ec">More...</a><br /></td></tr>
<tr class="separator:a17b8c6194383b6116eb78f307a7698ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd80fd2dcc0724c63b5bbe8b54b6345a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvsipl_1_1INvSIPLCamera.html#acd80fd2dcc0724c63b5bbe8b54b6345a">FillNvSciSyncAttrList</a> (uint32_t index, <a class="el" href="structnvsipl_1_1INvSIPLClient_1_1ConsumerDesc.html#a95eeca9f6deb4f6114d76c9e6ec25aac">INvSIPLClient::ConsumerDesc::OutputType</a> const outType, <a class="el" href="group__nvsci__sync.html#ga7460ea70ac4b6cff53792366e4f1e0fa">NvSciSyncAttrList</a> const attrList, <a class="el" href="namespacenvsipl.html#a164e91d6bb8596ddae43c1929356a8a8">NvSiplNvSciSyncClientType</a> const clientType)=0</td></tr>
<tr class="memdesc:acd80fd2dcc0724c63b5bbe8b54b6345a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill an <a class="el" href="group__nvsci__sync.html#ga7460ea70ac4b6cff53792366e4f1e0fa">NvSciSyncAttrList</a>.  <a href="classnvsipl_1_1INvSIPLCamera.html#acd80fd2dcc0724c63b5bbe8b54b6345a">More...</a><br /></td></tr>
<tr class="separator:acd80fd2dcc0724c63b5bbe8b54b6345a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220e761f59710bb9c290adefa0b57dc9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvsipl_1_1INvSIPLCamera.html#a220e761f59710bb9c290adefa0b57dc9">RegisterNvSciSyncObj</a> (uint32_t index, <a class="el" href="structnvsipl_1_1INvSIPLClient_1_1ConsumerDesc.html#a95eeca9f6deb4f6114d76c9e6ec25aac">INvSIPLClient::ConsumerDesc::OutputType</a> const outType, <a class="el" href="namespacenvsipl.html#ad1fbd0355942a3c8bed7d7282e67628f">NvSiplNvSciSyncObjType</a> const syncobjtype, <a class="el" href="group__nvsci__sync.html#gaceebe98c77e27e6cea03a2e53a005d11">NvSciSyncObj</a> const syncobj)=0</td></tr>
<tr class="memdesc:a220e761f59710bb9c290adefa0b57dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an <a class="el" href="group__nvsci__sync.html#gaceebe98c77e27e6cea03a2e53a005d11">NvSciSyncObj</a>.  <a href="classnvsipl_1_1INvSIPLCamera.html#a220e761f59710bb9c290adefa0b57dc9">More...</a><br /></td></tr>
<tr class="separator:a220e761f59710bb9c290adefa0b57dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b89abd1cd9a9df4c74bc09a7a501638"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvsipl_1_1INvSIPLCamera.html#a9b89abd1cd9a9df4c74bc09a7a501638">GetDeserializerInterfaceProvider</a> (uint32_t const devBlkIndex, IInterfaceProvider *&amp;interfaceProvider)=0</td></tr>
<tr class="memdesc:a9b89abd1cd9a9df4c74bc09a7a501638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve custom interface provider for deserializer.  <a href="classnvsipl_1_1INvSIPLCamera.html#a9b89abd1cd9a9df4c74bc09a7a501638">More...</a><br /></td></tr>
<tr class="separator:a9b89abd1cd9a9df4c74bc09a7a501638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b82cb80b571be6bc6f75c35549e4c7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvsipl_1_1INvSIPLCamera.html#a17b82cb80b571be6bc6f75c35549e4c7">GetModuleInterfaceProvider</a> (uint32_t const index, IInterfaceProvider *&amp;interfaceProvider)=0</td></tr>
<tr class="memdesc:a17b82cb80b571be6bc6f75c35549e4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve custom interface provider for module.  <a href="classnvsipl_1_1INvSIPLCamera.html#a17b82cb80b571be6bc6f75c35549e4c7">More...</a><br /></td></tr>
<tr class="separator:a17b82cb80b571be6bc6f75c35549e4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a11634bf312e15a083d45f92ed8791b04"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="classnvsipl_1_1INvSIPLCamera.html">INvSIPLCamera</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnvsipl_1_1INvSIPLCamera.html#a11634bf312e15a083d45f92ed8791b04">GetInstance</a> ()</td></tr>
<tr class="memdesc:a11634bf312e15a083d45f92ed8791b04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle to an <a class="el" href="classnvsipl_1_1INvSIPLCamera.html" title="The top-level API for SIPL.">INvSIPLCamera</a> instance.  <a href="classnvsipl_1_1INvSIPLCamera.html#a11634bf312e15a083d45f92ed8791b04">More...</a><br /></td></tr>
<tr class="separator:a11634bf312e15a083d45f92ed8791b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a17b8c6194383b6116eb78f307a7698ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17b8c6194383b6116eb78f307a7698ec">&#9670;&nbsp;</a></span>~INvSIPLCamera()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual nvsipl::INvSIPLCamera::~INvSIPLCamera </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aff3d0798198a31e1a7921c83ff5af3d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff3d0798198a31e1a7921c83ff5af3d0">&#9670;&nbsp;</a></span>Deinit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a> nvsipl::INvSIPLCamera::Deinit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deinitialize the API for the selected platform configuration. </p>
<p>This method deinitializes the camera module(s) and deserializer for each device block in the selected platform configuration, and deinitializes and destroys the image processing pipelines.</p>
<p>Any registered images are automatically deregistered and can be safely destroyed.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This function can be called anytime after <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#a5ea69c4c93f839ce6b86420b7cdb8ad0" title="Initialize the API for the selected platform configuration.">Init()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b" title="Defines the status codes returned by functions in SIPL modules.">SIPLStatus</a> the completion status of the operation.</dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt handler: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: No</li>
<li>Re-entrant: No</li>
<li>Async/Sync: Async</li>
</ul>
</li>
<li>Required privileges: Yes, with the following conditions:<ul>
<li>Grants: nonroot, allow</li>
<li>Abilities: public_channel</li>
<li>Application needs to have access to the SGIDs that SIPL depends on as mentioned in the NVIDIA DRIVE OS Safety Developer Guide</li>
</ul>
</li>
<li>API group<ul>
<li>Init: No</li>
<li>Runtime: No</li>
<li>De-Init: Yes </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="ab1e11396f0f08f226b9c13336d513b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1e11396f0f08f226b9c13336d513b89">&#9670;&nbsp;</a></span>DisableLink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a> nvsipl::INvSIPLCamera::DisableLink </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable a given link. </p>
<p>This method disables a given link.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This function should only be called after <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#ae265de46988e46f2719b0c075e721e19">Start()</a> and before <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#a4abc9d68fe563d07ad612b5c421da801">Stop()</a>.</dd></dl>
<p>Error notifications to the client are dropped until <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#ad05ba09cd61305ae62671a7e0533e7fd">EnableLink()</a> is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The ID of the sensor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b" title="Defines the status codes returned by functions in SIPL modules.">SIPLStatus</a> the completion status of the operation.</dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt handler: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: No</li>
<li>Re-entrant: Yes</li>
<li>Async/Sync: Sync</li>
</ul>
</li>
<li>Required privileges: Yes, with the following conditions:<ul>
<li>Grants: nonroot, allow</li>
<li>Abilities: public_channel</li>
<li>Application needs to have access to the SGIDs that SIPL depends on as mentioned in the NVIDIA DRIVE OS Safety Developer Guide</li>
</ul>
</li>
<li>API group<ul>
<li>Init: No</li>
<li>Runtime: Yes</li>
<li>De-Init: No </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="ad05ba09cd61305ae62671a7e0533e7fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad05ba09cd61305ae62671a7e0533e7fd">&#9670;&nbsp;</a></span>EnableLink()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a> nvsipl::INvSIPLCamera::EnableLink </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool const&#160;</td>
          <td class="paramname"><em>resetModule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable a given link. </p>
<p>This method enables a given link and, if reset is asserted, reconfigures the camera module to reestablish the link.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This function should only be called after <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#ae265de46988e46f2719b0c075e721e19">Start()</a> and before <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#a4abc9d68fe563d07ad612b5c421da801">Stop()</a>.</dd></dl>
<p>Error notifications to the client that were disabled by <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#ab1e11396f0f08f226b9c13336d513b89">DisableLink()</a> are resumed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The ID of the sensor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">resetModule</td><td>If true, reconfigure the camera module before enabling the link.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b" title="Defines the status codes returned by functions in SIPL modules.">SIPLStatus</a> the completion status of the operation.</dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt handler: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: No</li>
<li>Re-entrant: Yes</li>
<li>Async/Sync: Sync</li>
</ul>
</li>
<li>Required privileges: Yes, with the following conditions:<ul>
<li>Grants: nonroot, allow</li>
<li>Abilities: public_channel</li>
<li>Application needs to have access to the SGIDs that SIPL depends on as mentioned in the NVIDIA DRIVE OS Safety Developer Guide</li>
</ul>
</li>
<li>API group<ul>
<li>Init: No</li>
<li>Runtime: Yes</li>
<li>De-Init: No </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="acd80fd2dcc0724c63b5bbe8b54b6345a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd80fd2dcc0724c63b5bbe8b54b6345a">&#9670;&nbsp;</a></span>FillNvSciSyncAttrList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a> nvsipl::INvSIPLCamera::FillNvSciSyncAttrList </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvsipl_1_1INvSIPLClient_1_1ConsumerDesc.html#a95eeca9f6deb4f6114d76c9e6ec25aac">INvSIPLClient::ConsumerDesc::OutputType</a> const&#160;</td>
          <td class="paramname"><em>outType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvsci__sync.html#ga7460ea70ac4b6cff53792366e4f1e0fa">NvSciSyncAttrList</a> const&#160;</td>
          <td class="paramname"><em>attrList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenvsipl.html#a164e91d6bb8596ddae43c1929356a8a8">NvSiplNvSciSyncClientType</a> const&#160;</td>
          <td class="paramname"><em>clientType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fill an <a class="el" href="group__nvsci__sync.html#ga7460ea70ac4b6cff53792366e4f1e0fa">NvSciSyncAttrList</a>. </p>
<p>The method is used to fetch the NvSciSync attributes required for compatiblility with the underlying image processing pipelines.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This function must be called after <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#a5ea69c4c93f839ce6b86420b7cdb8ad0">Init()</a> and before <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#a220e761f59710bb9c290adefa0b57dc9">RegisterNvSciSyncObj()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The ID of the sensor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outType</td><td>The output for which NvSciSync attributes are being fetched. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">attrList</td><td>Attribute list to be filled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clientType</td><td>Waiter, signaler, or both.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b" title="Defines the status codes returned by functions in SIPL modules.">SIPLStatus</a> the completion status of the operation.</dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt handler: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: No</li>
<li>Re-entrant: No</li>
<li>Async/Sync: Sync</li>
</ul>
</li>
<li>Required privileges: Yes, with the following conditions:<ul>
<li>Grants: nonroot, allow</li>
<li>Abilities: public_channel</li>
<li>Application needs to have access to the SGIDs that SIPL depends on as mentioned in the NVIDIA DRIVE OS Safety Developer Guide</li>
</ul>
</li>
<li>API group<ul>
<li>Init: Yes</li>
<li>Runtime: No</li>
<li>De-Init: No </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="afa56c624e006571585cd3703477581d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa56c624e006571585cd3703477581d7">&#9670;&nbsp;</a></span>GetDeserializerErrorInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a> nvsipl::INvSIPLCamera::GetDeserializerErrorInfo </td>
          <td>(</td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>devBlkIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvsipl_1_1SIPLErrorDetails.html">SIPLErrorDetails</a> *const&#160;</td>
          <td class="paramname"><em>deserializerErrorInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>isRemoteError</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t &amp;&#160;</td>
          <td class="paramname"><em>linkErrorMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get generic deserializer error information. </p>
<p>This method queries the driver for detailed error information and populates a provided buffer for the deserializer associated with the device block index. The contents, size written, and order are determined by the driver.</p>
<p>If no error info is expected (max error size is 0), this may be called with null error info to retrieve only the remote and link error information.</p>
<p>It is expected that the provided buffer is the correct size for the driver-provided errors.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This function must be called after <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#a5ea69c4c93f839ce6b86420b7cdb8ad0">Init()</a> and before <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#a4abc9d68fe563d07ad612b5c421da801">Stop()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devBlkIndex</td><td>Index of the device block associated with the deserializer to retrieve information from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">deserializerErrorInfo</td><td><a class="el" href="structnvsipl_1_1SIPLErrorDetails.html" title="Error details for a particular device.">SIPLErrorDetails</a> buffer to populate with error information and the size of data written. Zero size means that no valid data was written. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">isRemoteError</td><td>bool set to true if remote (serializer) error detected. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">linkErrorMask</td><td>uint8_t to store link mask for link error state (1 in index position indicates error; all 0 means no link error detected).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b" title="Defines the status codes returned by functions in SIPL modules.">SIPLStatus</a> the completion status of the operation.</dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt handler: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: No</li>
<li>Re-entrant: Yes</li>
<li>Async/Sync: Sync</li>
</ul>
</li>
<li>Required privileges: Yes, with the following conditions:<ul>
<li>Grants: nonroot, allow</li>
<li>Abilities: public_channel</li>
<li>Application needs to have access to the SGIDs that SIPL depends on as mentioned in the NVIDIA DRIVE OS Safety Developer Guide</li>
</ul>
</li>
<li>API group<ul>
<li>Init: Yes</li>
<li>Runtime: Yes</li>
<li>De-Init: No </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="a9b89abd1cd9a9df4c74bc09a7a501638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b89abd1cd9a9df4c74bc09a7a501638">&#9670;&nbsp;</a></span>GetDeserializerInterfaceProvider()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a> nvsipl::INvSIPLCamera::GetDeserializerInterfaceProvider </td>
          <td>(</td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>devBlkIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IInterfaceProvider *&amp;&#160;</td>
          <td class="paramname"><em>interfaceProvider</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve custom interface provider for deserializer. </p>
<p>Retrieve the custom interface provider for the deserializer associated with the specified device block index. This allows for direct access to custom deserializer functionality.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This function must be called after <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#a5ea69c4c93f839ce6b86420b7cdb8ad0">Init()</a> and before <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#ae265de46988e46f2719b0c075e721e19">Start()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devBlkIndex</td><td>Index of the device block associated with the deserializer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">interfaceProvider</td><td>The custom interface provider for this deserializer. May be nullptr if no custom interfaces are implemented.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b" title="Defines the status codes returned by functions in SIPL modules.">SIPLStatus</a> the completion status of the operation.</dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt handler: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: No</li>
<li>Re-entrant: No</li>
<li>Async/Sync: Sync</li>
</ul>
</li>
<li>Required privileges: Yes, with the following conditions:<ul>
<li>Grants: nonroot, allow</li>
<li>Abilities: public_channel</li>
<li>Application needs to have access to the SGIDs that SIPL depends on as mentioned in the NVIDIA DRIVE OS Safety Developer Guide</li>
</ul>
</li>
<li>API group<ul>
<li>Init: Yes</li>
<li>Runtime: No</li>
<li>De-Init: No </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="a8931f2b886c136cb8d18bf0d07080e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8931f2b886c136cb8d18bf0d07080e2b">&#9670;&nbsp;</a></span>GetErrorGPIOEventInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a> nvsipl::INvSIPLCamera::GetErrorGPIOEventInfo </td>
          <td>(</td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>devBlkIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>gpioIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__NvSIPL.html#ga46665f08a63d55add49961ae3abbf9d4">SIPLGpioEvent</a> &amp;&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the error interrupt event information for a GPIO activation. </p>
<p>This method queries CDAC for the latest event code of a GPIO pin, called in response to Deserializer, Serializer and/or Sensor error notification(s).</p>
<p>This API is only supported on QNX with the Version 2 CDI API. NVSIPL_STATUS_NOT_SUPPORTED is returned on all other platforms.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This function must be called after <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#a5ea69c4c93f839ce6b86420b7cdb8ad0">Init()</a> and before <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#a4abc9d68fe563d07ad612b5c421da801">Stop()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devBlkIndex</td><td>Index of the device block associated with the error notification. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gpioIndex</td><td>Index of the CDAC Error GPIO that issued an interrupt event notification. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">event</td><td>The latest-updated CDAC GPIO event code.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b" title="Defines the status codes returned by functions in SIPL modules.">SIPLStatus</a> the completion status of the operation.</dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt handler: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: No</li>
<li>Re-entrant: Yes</li>
<li>Async/Sync: Sync</li>
</ul>
</li>
<li>Required privileges: Yes, with the following conditions:<ul>
<li>Grants: nonroot, allow</li>
<li>Abilities: public_channel</li>
<li>Application needs to have access to the SGIDs that SIPL depends on as mentioned in the NVIDIA DRIVE OS Safety Developer Guide</li>
</ul>
</li>
<li>API group<ul>
<li>Init: Yes</li>
<li>Runtime: Yes</li>
<li>De-Init: No </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="a800f20b2abb58897aa3c672e61bf5874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a800f20b2abb58897aa3c672e61bf5874">&#9670;&nbsp;</a></span>GetImageAttributes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a> nvsipl::INvSIPLCamera::GetImageAttributes </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvsipl_1_1INvSIPLClient_1_1ConsumerDesc.html#a95eeca9f6deb4f6114d76c9e6ec25aac">INvSIPLClient::ConsumerDesc::OutputType</a> const&#160;</td>
          <td class="paramname"><em>outType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvscibuf__attr__datastructures.html#ga45b3b5302a7d48333f3c03cc8d49a020">NvSciBufAttrList</a> &amp;&#160;</td>
          <td class="paramname"><em>imageAttr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get image attributes. </p>
<p>This method is used to get the attributes of the images to be used with the image processing pipeline. The user must reconcile the attributes returned by this function with the attributes required by the downstream consumers of the output of the pipeline and allocate the images.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This function must be called after <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#a5ea69c4c93f839ce6b86420b7cdb8ad0">Init()</a> but before <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#ae265de46988e46f2719b0c075e721e19">Start()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The ID of the sensor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outType</td><td>The output for which image attributes are being fetched. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">imageAttr</td><td>Reference to the image attributes structure. <ul>
<li>The surface type for ICP output is determined by the properties of the image sensor and must not be overridden by the user </li>
<li>The surface type for ISP0 output is set to the following by default for both RGB Bayer and RGB-IR sensor if not already set by the client. Note, if set by client it must only be to one of the supported surface types of ISP output listed in <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#aeb039b78b216013784654985346af728">RegisterImages</a> or an error will be generated.</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Surface Type </th><th class="markdownTableHeadNone">Layout </th><th class="markdownTableHeadNone">Data Type </th><th class="markdownTableHeadNone">Memory </th><th class="markdownTableHeadNone">Sub-sampling Type </th><th class="markdownTableHeadNone">Bits Per Component </th><th class="markdownTableHeadNone">Component Order </th><th class="markdownTableHeadNone">Color Standard  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">BLOCK LINEAR </td><td class="markdownTableBodyNone">UINT </td><td class="markdownTableBodyNone">SEMI PLANAR </td><td class="markdownTableBodyNone">420 </td><td class="markdownTableBodyNone">8 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">REC709_ER  </td></tr>
</table>
</td></tr>
  </table>
  </dd>
</dl>
<p>YUV 420 SEMI-PLANAR UINT8 Block Linear is defined by NvSciBuf with: NvSciBufImageAttrKey_SurfType set to NvSciSurfType_YUV NvSciBufImageAttrKey_SurfBPC set to NvSciSurfBPC_8 NvSciBufImageAttrKey_SurfMemLayout set to NvSciSurfMemLayout_SemiPlanar NvSciBufImageAttrKey_SurfSampleType set to NvSciSurfSampleType_420 NvSciBufImageAttrKey_SurfComponentOrder set to NvSciSurfComponentOrder_YUV NvSciBufImageAttrKey_SurfColorStd set to NvSciColorStd_REC709_ER NvSciBufImageAttrKey_Layout set to NvSciBufImage_BlockLinearType</p>
<ul>
<li>The surface type for ISP1 output is set to the following by default if not already set by the client. Note, if set by client it must only be to one of the supported surface types of ISP output listed in <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#aeb039b78b216013784654985346af728">RegisterImages</a> or an error will be generated.</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Surface Type </th><th class="markdownTableHeadNone">Layout </th><th class="markdownTableHeadNone">Data Type </th><th class="markdownTableHeadNone">Memory </th><th class="markdownTableHeadNone">Sub-sampling Type </th><th class="markdownTableHeadNone">Bits Per Component </th><th class="markdownTableHeadNone">Component Order </th><th class="markdownTableHeadNone">Color Standard </th><th class="markdownTableHeadNone">Sensor Type  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">BLOCK LINEAR </td><td class="markdownTableBodyNone">UINT </td><td class="markdownTableBodyNone">SEMI PLANAR </td><td class="markdownTableBodyNone">420 </td><td class="markdownTableBodyNone">8 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">REC709_ER </td><td class="markdownTableBodyNone">RGB Bayer  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Y </td><td class="markdownTableBodyNone">PITCH LINEAR </td><td class="markdownTableBodyNone">UINT </td><td class="markdownTableBodyNone">PACKED </td><td class="markdownTableBodyNone">N/A </td><td class="markdownTableBodyNone">16 </td><td class="markdownTableBodyNone">Y </td><td class="markdownTableBodyNone">REC709_ER </td><td class="markdownTableBodyNone">RGB-IR  </td></tr>
</table>
<p>YUV 420 SEMI-PLANAR UINT8 Block Linear is defined by NvSciBuf same as shown above for ISP0 Y PACKED UINT16 Pitch Linear is defined by NvSciBuf with: NvSciBufImageAttrKey_PlaneCount set to 1U NvSciBufImageAttrKey_PlaneColorFormat set with NvSciColor_Y16 NvSciBufImageAttrKey_PlaneColorStd set to NvSciColorStd_REC709_ER NvSciBufImageAttrKey_Layout set to NvSciBufImage_PitchLinearType</p>
<ul>
<li>The surface type for ISP2 output is set to the following by default if not already set by the client. Note, if set by client it must only be to one of the supported surface types of ISP output listed in <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#aeb039b78b216013784654985346af728">RegisterImages</a> or an error will be generated. note: ISP2 output is not supported for RGB-IR sensor <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Surface Type </th><th class="markdownTableHeadNone">Layout </th><th class="markdownTableHeadNone">Data Type </th><th class="markdownTableHeadNone">Memory </th><th class="markdownTableHeadNone">Sub-sampling Type </th><th class="markdownTableHeadNone">Bits Per Component </th><th class="markdownTableHeadNone">Component Order </th><th class="markdownTableHeadNone">Color Standard </th><th class="markdownTableHeadNone">Sensor Type  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">RGBA </td><td class="markdownTableBodyNone">PITCH LINEAR </td><td class="markdownTableBodyNone">FLOAT </td><td class="markdownTableBodyNone">PACKED </td><td class="markdownTableBodyNone">NONE </td><td class="markdownTableBodyNone">16 </td><td class="markdownTableBodyNone">RGBA </td><td class="markdownTableBodyNone">SENSOR_RGBA </td><td class="markdownTableBodyNone">RGB Bayer  </td></tr>
</table>
</li>
</ul>
<p>RGBA PACKED FLOAT16 Pitch Linear is defined by NvSciBuf with: NvSciBufImageAttrKey_PlaneCount set to 1U NvSciBufImageAttrKey_PlaneColorFormat set with NvSciColor_Float_A16 NvSciBufImageAttrKey_PlaneColorStd set to NvSciColorStd_SENSOR_RGBA NvSciBufImageAttrKey_Layout set to NvSciBufImage_PitchLinearType</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b" title="Defines the status codes returned by functions in SIPL modules.">SIPLStatus</a> the completion status of the operation.</dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt handler: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: No</li>
<li>Re-entrant: No</li>
<li>Async/Sync: Sync</li>
</ul>
</li>
<li>Required privileges: Yes, with the following conditions:<ul>
<li>Grants: nonroot, allow</li>
<li>Abilities: public_channel</li>
<li>Application needs to have access to the SGIDs that SIPL depends on as mentioned in the NVIDIA DRIVE OS Safety Developer Guide</li>
</ul>
</li>
<li>API group<ul>
<li>Init: Yes</li>
<li>Runtime: No</li>
<li>De-Init: No </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="a11634bf312e15a083d45f92ed8791b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11634bf312e15a083d45f92ed8791b04">&#9670;&nbsp;</a></span>GetInstance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::unique_ptr&lt;<a class="el" href="classnvsipl_1_1INvSIPLCamera.html">INvSIPLCamera</a>&gt; nvsipl::INvSIPLCamera::GetInstance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a handle to an <a class="el" href="classnvsipl_1_1INvSIPLCamera.html" title="The top-level API for SIPL.">INvSIPLCamera</a> instance. </p>
<p>Create an instance of the implementation class and return the handle. The object is automatically destroyed when the variable holding the return value goes out of scope.</p>
<dl class="section pre"><dt>Precondition</dt><dd>None.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a new <a class="el" href="classnvsipl_1_1INvSIPLCamera.html" title="The top-level API for SIPL.">INvSIPLCamera</a> instance.</dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt handler: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: No</li>
<li>Re-entrant: No</li>
<li>Async/Sync: Sync</li>
</ul>
</li>
<li>Required privileges: Yes, with the following conditions:<ul>
<li>Grants: nonroot, allow</li>
<li>Abilities: public_channel</li>
<li>Application needs to have access to the SGIDs that SIPL depends on as mentioned in the NVIDIA DRIVE OS Safety Developer Guide</li>
</ul>
</li>
<li>API group<ul>
<li>Init: Yes</li>
<li>Runtime: No</li>
<li>De-Init: No </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="a28f141ec53d5c3b165ae7dacb9e4341f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28f141ec53d5c3b165ae7dacb9e4341f">&#9670;&nbsp;</a></span>GetMaxErrorSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a> nvsipl::INvSIPLCamera::GetMaxErrorSize </td>
          <td>(</td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>devBlkIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>maxErrorSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get maximum size of error information. </p>
<p>This method queries the drivers for sizes of error information and returns the largest. This size should be used to allocate buffers for requesting detailed errors.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This function must be called after <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#a5ea69c4c93f839ce6b86420b7cdb8ad0">Init()</a> and before <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#ae265de46988e46f2719b0c075e721e19">Start()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">devBlkIndex</td><td>Index of the device block associated with the deserializer to retrieve error size from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">maxErrorSize</td><td>Maximum size of device error information, in bytes (0 if no valid size found).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b" title="Defines the status codes returned by functions in SIPL modules.">SIPLStatus</a> the completion status of the operation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structnvsipl_1_1SIPLErrorDetails.html" title="Error details for a particular device.">SIPLErrorDetails</a></dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt handler: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: No</li>
<li>Re-entrant: Yes</li>
<li>Async/Sync: Sync</li>
</ul>
</li>
<li>Required privileges: Yes, with the following conditions:<ul>
<li>Grants: nonroot, allow</li>
<li>Abilities: public_channel</li>
<li>Application needs to have access to the SGIDs that SIPL depends on as mentioned in the NVIDIA DRIVE OS Safety Developer Guide</li>
</ul>
</li>
<li>API group<ul>
<li>Init: Yes</li>
<li>Runtime: No</li>
<li>De-Init: No </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="ac068d23caf12c4f815c0601aec944257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac068d23caf12c4f815c0601aec944257">&#9670;&nbsp;</a></span>GetModuleErrorInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a> nvsipl::INvSIPLCamera::GetModuleErrorInfo </td>
          <td>(</td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvsipl_1_1SIPLErrorDetails.html">SIPLErrorDetails</a> *const&#160;</td>
          <td class="paramname"><em>serializerErrorInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvsipl_1_1SIPLErrorDetails.html">SIPLErrorDetails</a> *const&#160;</td>
          <td class="paramname"><em>sensorErrorInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__NvSIPL.html#ga28a556387b46941209b9ee75065a950f">SIPLModuleErrorReadFlag</a> const&#160;</td>
          <td class="paramname"><em>errorsToRead</em> = <code><a class="el" href="group__NvSIPL.html#gga28a556387b46941209b9ee75065a950fa97170f0579dccf4daedd39f92c70b6a7">NVSIPL_MODULE_ERROR_READ_ALL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets generic module error information. </p>
<p>This method queries the drivers for detailed error information and populates a provided buffer for module devices (sensor, serializer) associated with the index. The contents, size written, and order are determined by each driver.</p>
<p>It is expected that the provided buffers are the correct size for the driver-provided errors.</p>
<p>A flag is provided indicating whether sensor, serializer, or both errors should be read. If not read, the errorInfo may be null for that device.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This function must be called after <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#a5ea69c4c93f839ce6b86420b7cdb8ad0">Init()</a> and before <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#a4abc9d68fe563d07ad612b5c421da801">Stop()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>ID of the sensor associated with the devices to retrieve error information from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">serializerErrorInfo</td><td>Buffer to populate with serializer error information and the size of data written. Zero size means that no valid data was written. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sensorErrorInfo</td><td>Buffer to populate with sensor error information and the size of data written. Zero size means that no valid data was written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">errorsToRead</td><td>Flag indicating which errors to read - sensor, serializer, or both. If this flag indicates that errors should be read, the corresponding <a class="el" href="structnvsipl_1_1SIPLErrorDetails.html" title="Error details for a particular device.">SIPLErrorDetails</a> must be valid. Default behavior is to read both.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b" title="Defines the status codes returned by functions in SIPL modules.">SIPLStatus</a> the completion status of the operation.</dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt handler: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: No</li>
<li>Re-entrant: Yes</li>
<li>Async/Sync: Sync</li>
</ul>
</li>
<li>Required privileges: Yes, with the following conditions:<ul>
<li>Grants: nonroot, allow</li>
<li>Abilities: public_channel</li>
<li>Application needs to have access to the SGIDs that SIPL depends on as mentioned in the NVIDIA DRIVE OS Safety Developer Guide</li>
</ul>
</li>
<li>API group<ul>
<li>Init: Yes</li>
<li>Runtime: Yes</li>
<li>De-Init: No </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="a17b82cb80b571be6bc6f75c35549e4c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17b82cb80b571be6bc6f75c35549e4c7">&#9670;&nbsp;</a></span>GetModuleInterfaceProvider()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a> nvsipl::INvSIPLCamera::GetModuleInterfaceProvider </td>
          <td>(</td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IInterfaceProvider *&amp;&#160;</td>
          <td class="paramname"><em>interfaceProvider</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve custom interface provider for module. </p>
<p>Retrieve the custom interface provider for the module associated with the specified sensor index. This allows for direct access to custom module functionality.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This function must be called after <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#a5ea69c4c93f839ce6b86420b7cdb8ad0">Init()</a> and before <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#ae265de46988e46f2719b0c075e721e19">Start()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>ID of the sensor associated with the module to retrieve interface from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">interfaceProvider</td><td>The customer interface provider for this module. May be nullptr if no custom interfaces are implemented.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b" title="Defines the status codes returned by functions in SIPL modules.">SIPLStatus</a> the completion status of the operation.</dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt handler: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: No</li>
<li>Re-entrant: No</li>
<li>Async/Sync: Sync</li>
</ul>
</li>
<li>Required privileges: Yes, with the following conditions:<ul>
<li>Grants: nonroot, allow</li>
<li>Abilities: public_channel</li>
<li>Application needs to have access to the SGIDs that SIPL depends on as mentioned in the NVIDIA DRIVE OS Safety Developer Guide</li>
</ul>
</li>
<li>API group<ul>
<li>Init: Yes</li>
<li>Runtime: No</li>
<li>De-Init: No </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="a5ea69c4c93f839ce6b86420b7cdb8ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ea69c4c93f839ce6b86420b7cdb8ad0">&#9670;&nbsp;</a></span>Init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a> nvsipl::INvSIPLCamera::Init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize the API for the selected platform configuration. </p>
<p>The method internally initializes the camera module(s) and deserializer for each device block in the selected platform configuration, and creates and initializes the image processing pipelines based on the number and type of the outputs set via <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#ab8908aaf6991482b0a67ce2684234e6e">SetPipelineCfg</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This function must be called must be called after <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#ab8908aaf6991482b0a67ce2684234e6e">SetPipelineCfg()</a> but before <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#aeb039b78b216013784654985346af728">RegisterImages</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b" title="Defines the status codes returned by functions in SIPL modules.">SIPLStatus</a> the completion status of the operation.</dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt handler: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: No</li>
<li>Re-entrant: No</li>
<li>Async/Sync: Sync</li>
</ul>
</li>
<li>Required privileges: Yes, with the following conditions:<ul>
<li>Grants: nonroot, allow</li>
<li>Abilities: public_channel</li>
<li>Application needs to have access to the SGIDs that SIPL depends on as mentioned in the NVIDIA DRIVE OS Safety Developer Guide</li>
</ul>
</li>
<li>API group<ul>
<li>Init: Yes</li>
<li>Runtime: No</li>
<li>De-Init: No </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="a34e21ab1bbd3faca3dd46f7fc8a2af7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e21ab1bbd3faca3dd46f7fc8a2af7f">&#9670;&nbsp;</a></span>ReadEEPROMData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a> nvsipl::INvSIPLCamera::ReadEEPROMData </td>
          <td>(</td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t const&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read from an EEPROM in a camera module. </p>
<p>This method is used to perform data reads from an EEPROM in a camera module.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This function can only be called after <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#a5ea69c4c93f839ce6b86420b7cdb8ad0">Init()</a> but before <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#ae265de46988e46f2719b0c075e721e19">Start()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The ID of the sensor to which the EEPROM is associated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">address</td><td>The start address to read from in the EEPROM. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Contiguous size of data to be read. [byte] </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>Buffer that EEPROM data is to be written into, must be at least size length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b" title="Defines the status codes returned by functions in SIPL modules.">SIPLStatus</a>. The completion status of the operation.</dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt handler: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: No</li>
<li>Re-entrant: Yes</li>
<li>Async/Sync: Sync</li>
</ul>
</li>
<li>Required privileges: Yes, with the following conditions:<ul>
<li>Grants: nonroot, allow</li>
<li>Abilities: public_channel</li>
<li>Application needs to have access to the SGIDs that SIPL depends on as mentioned in the NVIDIA DRIVE OS Safety Developer Guide</li>
</ul>
</li>
<li>API group<ul>
<li>Init: Yes</li>
<li>Runtime: No</li>
<li>De-Init: No </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="aaba89991ad75bef5b9abf95002c5adcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba89991ad75bef5b9abf95002c5adcf">&#9670;&nbsp;</a></span>RegisterAutoControlPlugin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a> nvsipl::INvSIPLCamera::RegisterAutoControlPlugin </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__NvSIPLAutoControl.html#ga5d84afd445c05b3e5aa836ae436ea454">PluginType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classnvsipl_1_1ISiplControlAuto.html">ISiplControlAuto</a> *const&#160;</td>
          <td class="paramname"><em>autoControl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; const &amp;&#160;</td>
          <td class="paramname"><em>blob</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register the Auto Control plugin to be used for a specific pipeline. </p>
<p>This method must be called for every pipeline with ISP output enabled.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This function must be called after <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#aeb039b78b216013784654985346af728">RegisterImages()</a> but before <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#ae265de46988e46f2719b0c075e721e19">Start()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The ID of the sensor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>Auto Control plugin type. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">autoControl</td><td>Handle to plugin implementation, or nullptr if type is NV_PLUGIN. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blob</td><td>Reference to binary blob containing the ISP configuration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b" title="Defines the status codes returned by functions in SIPL modules.">SIPLStatus</a> the completion status of the operation.</dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt handler: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: No</li>
<li>Re-entrant: No</li>
<li>Async/Sync: Sync</li>
</ul>
</li>
<li>Required privileges: Yes, with the following conditions:<ul>
<li>Grants: nonroot, allow</li>
<li>Abilities: public_channel</li>
<li>Application needs to have access to the SGIDs that SIPL depends on as mentioned in the NVIDIA DRIVE OS Safety Developer Guide</li>
</ul>
</li>
<li>API group<ul>
<li>Init: Yes</li>
<li>Runtime: No</li>
<li>De-Init: No </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="aeb039b78b216013784654985346af728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb039b78b216013784654985346af728">&#9670;&nbsp;</a></span>RegisterImages()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a> nvsipl::INvSIPLCamera::RegisterImages </td>
          <td>(</td>
          <td class="paramtype">uint32_t const&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvsipl_1_1INvSIPLClient_1_1ConsumerDesc.html#a95eeca9f6deb4f6114d76c9e6ec25aac">INvSIPLClient::ConsumerDesc::OutputType</a> const&#160;</td>
          <td class="paramname"><em>outType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="group__nvscibuf__attr__datastructures.html#ga64cc45c7902fc2498c079097942e875b">NvSciBufObj</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>images</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register images. </p>
<p>This method is used to register the images to be used within the image processing pipelines. These images serve as the output of ISP or as the output of ICP and input to ISP.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This function must be called after <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#a5ea69c4c93f839ce6b86420b7cdb8ad0">Init()</a> and before <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#ae265de46988e46f2719b0c075e721e19">Start()</a>. Additionally, if ISP output is enabled it must be called before <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#aaba89991ad75bef5b9abf95002c5adcf">RegisterAutoControlPlugin()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The ID of the sensor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outType</td><td>The output which images are being registered; can be ICP, ISP0 or ISP1. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">images</td><td>Vector of <a class="el" href="group__nvscibuf__attr__datastructures.html#ga64cc45c7902fc2498c079097942e875b">NvSciBufObj</a> to be registered. <ul>
<li>Supported number of images that can be registered: [1, 64] </li>
<li>Supported surface formats for ISP0 output for both RGB Bayer and RGB-IR sensor:</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Row # </th><th class="markdownTableHeadNone">Surface Type </th><th class="markdownTableHeadNone">Layout </th><th class="markdownTableHeadNone">Data Type </th><th class="markdownTableHeadNone">Memory </th><th class="markdownTableHeadNone">Sub-sampling Type </th><th class="markdownTableHeadNone">Bits Per Component </th><th class="markdownTableHeadNone">Component Order </th><th class="markdownTableHeadNone">Color Standard  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">BLOCK LINEAR </td><td class="markdownTableBodyNone">UINT </td><td class="markdownTableBodyNone">SEMI PLANAR </td><td class="markdownTableBodyNone">420 </td><td class="markdownTableBodyNone">8 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">REC709_ER  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">2 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">PITCH LINEAR </td><td class="markdownTableBodyNone">UINT </td><td class="markdownTableBodyNone">SEMI PLANAR </td><td class="markdownTableBodyNone">420 </td><td class="markdownTableBodyNone">8 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">REC709_ER  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">3 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">BLOCK LINEAR </td><td class="markdownTableBodyNone">UINT </td><td class="markdownTableBodyNone">SEMI PLANAR </td><td class="markdownTableBodyNone">420 </td><td class="markdownTableBodyNone">16 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">REC709_ER  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">4 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">PITCH LINEAR </td><td class="markdownTableBodyNone">UINT </td><td class="markdownTableBodyNone">SEMI PLANAR </td><td class="markdownTableBodyNone">420 </td><td class="markdownTableBodyNone">16 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">REC709_ER  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">5 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">BLOCK LINEAR </td><td class="markdownTableBodyNone">UINT </td><td class="markdownTableBodyNone">PACKED </td><td class="markdownTableBodyNone">NONE </td><td class="markdownTableBodyNone">8 </td><td class="markdownTableBodyNone">VUYX </td><td class="markdownTableBodyNone">REC709_ER  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">6 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">PITCH LINEAR </td><td class="markdownTableBodyNone">UINT </td><td class="markdownTableBodyNone">PACKED </td><td class="markdownTableBodyNone">NONE </td><td class="markdownTableBodyNone">8 </td><td class="markdownTableBodyNone">VUYX </td><td class="markdownTableBodyNone">REC709_ER  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">7 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">PITCH LINEAR </td><td class="markdownTableBodyNone">UINT </td><td class="markdownTableBodyNone">PACKED </td><td class="markdownTableBodyNone">NONE </td><td class="markdownTableBodyNone">16 </td><td class="markdownTableBodyNone">VUYX </td><td class="markdownTableBodyNone">REC709_ER  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">8 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">BLOCK LINEAR </td><td class="markdownTableBodyNone">UINT </td><td class="markdownTableBodyNone">SEMI PLANAR </td><td class="markdownTableBodyNone">444 </td><td class="markdownTableBodyNone">8 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">REC709_ER  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">9 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">PITCH LINEAR </td><td class="markdownTableBodyNone">UINT </td><td class="markdownTableBodyNone">SEMI PLANAR </td><td class="markdownTableBodyNone">444 </td><td class="markdownTableBodyNone">8 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">REC709_ER  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">10 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">BLOCK LINEAR </td><td class="markdownTableBodyNone">UINT </td><td class="markdownTableBodyNone">SEMI PLANAR </td><td class="markdownTableBodyNone">444 </td><td class="markdownTableBodyNone">16 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">REC709_ER  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">11 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">PITCH LINEAR </td><td class="markdownTableBodyNone">UINT </td><td class="markdownTableBodyNone">SEMI PLANAR </td><td class="markdownTableBodyNone">444 </td><td class="markdownTableBodyNone">16 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">REC709_ER  </td></tr>
</table>
</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>Supported surface formats for ISP1 output:</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Row # </th><th class="markdownTableHeadNone">Surface Type </th><th class="markdownTableHeadNone">Layout </th><th class="markdownTableHeadNone">Data Type </th><th class="markdownTableHeadNone">Memory </th><th class="markdownTableHeadNone">Sub-sampling Type </th><th class="markdownTableHeadNone">Bits Per Component </th><th class="markdownTableHeadNone">Component Order </th><th class="markdownTableHeadNone">Color Standard </th><th class="markdownTableHeadNone">Sensor Type  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">BLOCK LINEAR </td><td class="markdownTableBodyNone">UINT </td><td class="markdownTableBodyNone">SEMI PLANAR </td><td class="markdownTableBodyNone">420 </td><td class="markdownTableBodyNone">8 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">REC709_ER </td><td class="markdownTableBodyNone">RGB Bayer  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">2 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">PITCH LINEAR </td><td class="markdownTableBodyNone">UINT </td><td class="markdownTableBodyNone">SEMI PLANAR </td><td class="markdownTableBodyNone">420 </td><td class="markdownTableBodyNone">8 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">REC709_ER </td><td class="markdownTableBodyNone">RGB Bayer  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">3 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">BLOCK LINEAR </td><td class="markdownTableBodyNone">UINT </td><td class="markdownTableBodyNone">SEMI PLANAR </td><td class="markdownTableBodyNone">420 </td><td class="markdownTableBodyNone">16 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">REC709_ER </td><td class="markdownTableBodyNone">RGB Bayer  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">4 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">PITCH LINEAR </td><td class="markdownTableBodyNone">UINT </td><td class="markdownTableBodyNone">SEMI PLANAR </td><td class="markdownTableBodyNone">420 </td><td class="markdownTableBodyNone">16 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">REC709_ER </td><td class="markdownTableBodyNone">RGB Bayer  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">5 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">BLOCK LINEAR </td><td class="markdownTableBodyNone">UINT </td><td class="markdownTableBodyNone">PACKED </td><td class="markdownTableBodyNone">NONE </td><td class="markdownTableBodyNone">8 </td><td class="markdownTableBodyNone">VUYX </td><td class="markdownTableBodyNone">REC709_ER </td><td class="markdownTableBodyNone">RGB Bayer  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">6 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">PITCH LINEAR </td><td class="markdownTableBodyNone">UINT </td><td class="markdownTableBodyNone">PACKED </td><td class="markdownTableBodyNone">NONE </td><td class="markdownTableBodyNone">8 </td><td class="markdownTableBodyNone">VUYX </td><td class="markdownTableBodyNone">REC709_ER </td><td class="markdownTableBodyNone">RGB Bayer  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">7 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">PITCH LINEAR </td><td class="markdownTableBodyNone">UINT </td><td class="markdownTableBodyNone">PACKED </td><td class="markdownTableBodyNone">NONE </td><td class="markdownTableBodyNone">16 </td><td class="markdownTableBodyNone">VUYX </td><td class="markdownTableBodyNone">REC709_ER </td><td class="markdownTableBodyNone">RGB Bayer  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">8 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">BLOCK LINEAR </td><td class="markdownTableBodyNone">UINT </td><td class="markdownTableBodyNone">SEMI PLANAR </td><td class="markdownTableBodyNone">444 </td><td class="markdownTableBodyNone">8 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">REC709_ER </td><td class="markdownTableBodyNone">RGB Bayer  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">9 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">PITCH LINEAR </td><td class="markdownTableBodyNone">UINT </td><td class="markdownTableBodyNone">SEMI PLANAR </td><td class="markdownTableBodyNone">444 </td><td class="markdownTableBodyNone">8 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">REC709_ER </td><td class="markdownTableBodyNone">RGB Bayer  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">10 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">BLOCK LINEAR </td><td class="markdownTableBodyNone">UINT </td><td class="markdownTableBodyNone">SEMI PLANAR </td><td class="markdownTableBodyNone">444 </td><td class="markdownTableBodyNone">16 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">REC709_ER </td><td class="markdownTableBodyNone">RGB Bayer  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">11 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">PITCH LINEAR </td><td class="markdownTableBodyNone">UINT </td><td class="markdownTableBodyNone">SEMI PLANAR </td><td class="markdownTableBodyNone">444 </td><td class="markdownTableBodyNone">16 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">REC709_ER </td><td class="markdownTableBodyNone">RGB Bayer  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">12 </td><td class="markdownTableBodyNone">Y </td><td class="markdownTableBodyNone">PITCH LINEAR </td><td class="markdownTableBodyNone">UINT </td><td class="markdownTableBodyNone">PACKED </td><td class="markdownTableBodyNone">N/A </td><td class="markdownTableBodyNone">16 </td><td class="markdownTableBodyNone">Y </td><td class="markdownTableBodyNone">REC709_ER </td><td class="markdownTableBodyNone">RGB-IR  </td></tr>
</table>
<ul>
<li>Supported surface formats for ISP2 output: note: ISP2 output is not supported for RGB-IR sensor</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Row # </th><th class="markdownTableHeadNone">Surface Type </th><th class="markdownTableHeadNone">Layout </th><th class="markdownTableHeadNone">Data Type </th><th class="markdownTableHeadNone">Memory </th><th class="markdownTableHeadNone">Sub-sampling Type </th><th class="markdownTableHeadNone">Bits Per Component </th><th class="markdownTableHeadNone">Component Order </th><th class="markdownTableHeadNone">Color Standard </th><th class="markdownTableHeadNone">Sensor Type  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">BLOCK LINEAR </td><td class="markdownTableBodyNone">UINT </td><td class="markdownTableBodyNone">SEMI PLANAR </td><td class="markdownTableBodyNone">420 </td><td class="markdownTableBodyNone">8 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">REC709_ER </td><td class="markdownTableBodyNone">RGB Bayer  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">2 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">PITCH LINEAR </td><td class="markdownTableBodyNone">UINT </td><td class="markdownTableBodyNone">SEMI PLANAR </td><td class="markdownTableBodyNone">420 </td><td class="markdownTableBodyNone">8 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">REC709_ER </td><td class="markdownTableBodyNone">RGB Bayer  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">3 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">BLOCK LINEAR </td><td class="markdownTableBodyNone">UINT </td><td class="markdownTableBodyNone">SEMI PLANAR </td><td class="markdownTableBodyNone">420 </td><td class="markdownTableBodyNone">16 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">REC709_ER </td><td class="markdownTableBodyNone">RGB Bayer  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">4 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">PITCH LINEAR </td><td class="markdownTableBodyNone">UINT </td><td class="markdownTableBodyNone">SEMI PLANAR </td><td class="markdownTableBodyNone">420 </td><td class="markdownTableBodyNone">16 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">REC709_ER </td><td class="markdownTableBodyNone">RGB Bayer  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">5 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">BLOCK LINEAR </td><td class="markdownTableBodyNone">UINT </td><td class="markdownTableBodyNone">PACKED </td><td class="markdownTableBodyNone">NONE </td><td class="markdownTableBodyNone">8 </td><td class="markdownTableBodyNone">VUYX </td><td class="markdownTableBodyNone">REC709_ER </td><td class="markdownTableBodyNone">RGB Bayer  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">6 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">PITCH LINEAR </td><td class="markdownTableBodyNone">UINT </td><td class="markdownTableBodyNone">PACKED </td><td class="markdownTableBodyNone">NONE </td><td class="markdownTableBodyNone">8 </td><td class="markdownTableBodyNone">VUYX </td><td class="markdownTableBodyNone">REC709_ER </td><td class="markdownTableBodyNone">RGB Bayer  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">7 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">PITCH LINEAR </td><td class="markdownTableBodyNone">UINT </td><td class="markdownTableBodyNone">PACKED </td><td class="markdownTableBodyNone">NONE </td><td class="markdownTableBodyNone">16 </td><td class="markdownTableBodyNone">VUYX </td><td class="markdownTableBodyNone">REC709_ER </td><td class="markdownTableBodyNone">RGB Bayer  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">8 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">BLOCK LINEAR </td><td class="markdownTableBodyNone">UINT </td><td class="markdownTableBodyNone">SEMI PLANAR </td><td class="markdownTableBodyNone">444 </td><td class="markdownTableBodyNone">8 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">REC709_ER </td><td class="markdownTableBodyNone">RGB Bayer  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">9 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">PITCH LINEAR </td><td class="markdownTableBodyNone">UINT </td><td class="markdownTableBodyNone">SEMI PLANAR </td><td class="markdownTableBodyNone">444 </td><td class="markdownTableBodyNone">8 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">REC709_ER </td><td class="markdownTableBodyNone">RGB Bayer  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">10 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">BLOCK LINEAR </td><td class="markdownTableBodyNone">UINT </td><td class="markdownTableBodyNone">SEMI PLANAR </td><td class="markdownTableBodyNone">444 </td><td class="markdownTableBodyNone">16 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">REC709_ER </td><td class="markdownTableBodyNone">RGB Bayer  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">11 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">PITCH LINEAR </td><td class="markdownTableBodyNone">UINT </td><td class="markdownTableBodyNone">SEMI PLANAR </td><td class="markdownTableBodyNone">444 </td><td class="markdownTableBodyNone">16 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">REC709_ER </td><td class="markdownTableBodyNone">RGB Bayer  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">12 </td><td class="markdownTableBodyNone">RGBA </td><td class="markdownTableBodyNone">PITCH LINEAR </td><td class="markdownTableBodyNone">FLOAT </td><td class="markdownTableBodyNone">PACKED </td><td class="markdownTableBodyNone">NONE </td><td class="markdownTableBodyNone">16 </td><td class="markdownTableBodyNone">RGBA </td><td class="markdownTableBodyNone">SENSOR_RGBA </td><td class="markdownTableBodyNone">RGB-Bayer  </td></tr>
</table>
<ul>
<li>Supported surface formats for ICP output:</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Row # </th><th class="markdownTableHeadNone">Surface Type </th><th class="markdownTableHeadNone">Layout </th><th class="markdownTableHeadNone">Data Type </th><th class="markdownTableHeadNone">Memory </th><th class="markdownTableHeadNone">Sub-sampling Type </th><th class="markdownTableHeadNone">Bits Per Component </th><th class="markdownTableHeadNone">Component Order  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1 </td><td class="markdownTableBodyNone">RAW </td><td class="markdownTableBodyNone">PITCH LINEAR </td><td class="markdownTableBodyNone">UINT </td><td class="markdownTableBodyNone">PACKED </td><td class="markdownTableBodyNone">NONE </td><td class="markdownTableBodyNone">10 </td><td class="markdownTableBodyNone">{RGGB, BGGR, GRBG, GBRG, RCCB, BCCR, CRBC, CBRC, CCCC, BGGI_RGGI, GBIG_GRIG, GIBG_GIRG, IGGB_IGGR, RGGI_BGGI, GRIG_GBIG, GIRG_GIBG, IGGR_IGGB}  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">2 </td><td class="markdownTableBodyNone">RAW </td><td class="markdownTableBodyNone">PITCH LINEAR </td><td class="markdownTableBodyNone">UINT </td><td class="markdownTableBodyNone">PACKED </td><td class="markdownTableBodyNone">NONE </td><td class="markdownTableBodyNone">12 </td><td class="markdownTableBodyNone">{RGGB, BGGR, GRBG, GBRG, RCCB, BCCR, CRBC, CBRC, CCCC}  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">3 </td><td class="markdownTableBodyNone">RAW </td><td class="markdownTableBodyNone">PITCH LINEAR </td><td class="markdownTableBodyNone">UINT </td><td class="markdownTableBodyNone">PACKED </td><td class="markdownTableBodyNone">NONE </td><td class="markdownTableBodyNone">16 </td><td class="markdownTableBodyNone">{RGGB, BGGR, GRBG, GBRG, RCCB, BCCR, CRBC, CBRC, CCCC}  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">4 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">PITCH LINEAR </td><td class="markdownTableBodyNone">UINT </td><td class="markdownTableBodyNone">SEMI PLANAR </td><td class="markdownTableBodyNone">422 </td><td class="markdownTableBodyNone">8 </td><td class="markdownTableBodyNone">{YUV, YVU}  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">5 </td><td class="markdownTableBodyNone">YUV </td><td class="markdownTableBodyNone">PITCH LINEAR </td><td class="markdownTableBodyNone">UINT </td><td class="markdownTableBodyNone">PACKED </td><td class="markdownTableBodyNone">422 </td><td class="markdownTableBodyNone">8 </td><td class="markdownTableBodyNone">{YUYV, YVYU, VYUY, UYVY}  </td></tr>
</table>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b" title="Defines the status codes returned by functions in SIPL modules.">SIPLStatus</a> the completion status of the operation.</dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt handler: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: No</li>
<li>Re-entrant: No</li>
<li>Async/Sync: Sync</li>
</ul>
</li>
<li>Required privileges: Yes, with the following conditions:<ul>
<li>Grants: nonroot, allow</li>
<li>Abilities: public_channel</li>
<li>Application needs to have access to the SGIDs that SIPL depends on as mentioned in the NVIDIA DRIVE OS Safety Developer Guide</li>
</ul>
</li>
<li>API group<ul>
<li>Init: Yes</li>
<li>Runtime: No</li>
<li>De-Init: No </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="a220e761f59710bb9c290adefa0b57dc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a220e761f59710bb9c290adefa0b57dc9">&#9670;&nbsp;</a></span>RegisterNvSciSyncObj()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a> nvsipl::INvSIPLCamera::RegisterNvSciSyncObj </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvsipl_1_1INvSIPLClient_1_1ConsumerDesc.html#a95eeca9f6deb4f6114d76c9e6ec25aac">INvSIPLClient::ConsumerDesc::OutputType</a> const&#160;</td>
          <td class="paramname"><em>outType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacenvsipl.html#ad1fbd0355942a3c8bed7d7282e67628f">NvSiplNvSciSyncObjType</a> const&#160;</td>
          <td class="paramname"><em>syncobjtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nvsci__sync.html#gaceebe98c77e27e6cea03a2e53a005d11">NvSciSyncObj</a> const&#160;</td>
          <td class="paramname"><em>syncobj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register an <a class="el" href="group__nvsci__sync.html#gaceebe98c77e27e6cea03a2e53a005d11">NvSciSyncObj</a>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>This function must be called after <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#acd80fd2dcc0724c63b5bbe8b54b6345a">FillNvSciSyncAttrList()</a> and before <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#ae265de46988e46f2719b0c075e721e19">Start()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The ID of the sensor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">outType</td><td>The output for which the NvSciSyncObj is being registered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">syncobjtype</td><td>Presync, EOF sync, or presync and EOF sync. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">syncobj</td><td>The object to be registered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b" title="Defines the status codes returned by functions in SIPL modules.">SIPLStatus</a> the completion status of the operation.</dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt handler: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: No</li>
<li>Re-entrant: No</li>
<li>Async/Sync: Sync</li>
</ul>
</li>
<li>Required privileges: Yes, with the following conditions:<ul>
<li>Grants: nonroot, allow</li>
<li>Abilities: public_channel</li>
<li>Application needs to have access to the SGIDs that SIPL depends on as mentioned in the NVIDIA DRIVE OS Safety Developer Guide</li>
</ul>
</li>
<li>API group<ul>
<li>Init: Yes</li>
<li>Runtime: No</li>
<li>De-Init: No </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="ab8908aaf6991482b0a67ce2684234e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8908aaf6991482b0a67ce2684234e6e">&#9670;&nbsp;</a></span>SetPipelineCfg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a> nvsipl::INvSIPLCamera::SetPipelineCfg </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvsipl_1_1NvSIPLPipelineConfiguration.html">NvSIPLPipelineConfiguration</a> const &amp;&#160;</td>
          <td class="paramname"><em>pipelineCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvsipl_1_1NvSIPLPipelineQueues.html">NvSIPLPipelineQueues</a> &amp;&#160;</td>
          <td class="paramname"><em>queues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a pipeline configuration. </p>
<p>This method sets a camera pipeline configuration.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This function must be called after <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#a87e541fb56092ed4f3a6ab81fe7ef995">SetPlatformCfg()</a> but before <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#a5ea69c4c93f839ce6b86420b7cdb8ad0">Init()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The ID of the sensor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pipelineCfg</td><td>The pipeline configuration to set. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">queues</td><td>The queues that will deliver completed frames and events to the client.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b" title="Defines the status codes returned by functions in SIPL modules.">SIPLStatus</a> the completion status of the operation.</dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt handler: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: No</li>
<li>Re-entrant: No</li>
<li>Async/Sync: Sync</li>
</ul>
</li>
<li>Required privileges: Yes, with the following conditions:<ul>
<li>Grants: nonroot, allow</li>
<li>Abilities: public_channel</li>
<li>Application needs to have access to the SGIDs that SIPL depends on as mentioned in the NVIDIA DRIVE OS Safety Developer Guide</li>
</ul>
</li>
<li>API group<ul>
<li>Init: Yes</li>
<li>Runtime: No</li>
<li>De-Init: No </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="a87e541fb56092ed4f3a6ab81fe7ef995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87e541fb56092ed4f3a6ab81fe7ef995">&#9670;&nbsp;</a></span>SetPlatformCfg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a> nvsipl::INvSIPLCamera::SetPlatformCfg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvsipl_1_1PlatformCfg.html">PlatformCfg</a> const *const&#160;</td>
          <td class="paramname"><em>platformConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a platform configuration. </p>
<p>This method sets a <a class="el" href="structnvsipl_1_1PlatformCfg.html">PlatformCfg</a> camera platform configuration. The configuration specifies all sensors that will be used by this client. This method must be called before <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#ab8908aaf6991482b0a67ce2684234e6e">SetPipelineCfg()</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>None.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">platformConfig</td><td>The platform configuration. The external devices referenced in the platform configuration must be supported by the SIPL Device Block drivers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b" title="Defines the status codes returned by functions in SIPL modules.">SIPLStatus</a> the completion status of the operation.</dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt handler: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: No</li>
<li>Re-entrant: No</li>
<li>Async/Sync: Sync</li>
</ul>
</li>
<li>Required privileges: Yes, with the following conditions:<ul>
<li>Grants: nonroot, allow</li>
<li>Abilities: public_channel</li>
<li>Application needs to have access to the SGIDs that SIPL depends on as mentioned in the NVIDIA DRIVE OS Safety Developer Guide</li>
</ul>
</li>
<li>API group<ul>
<li>Init: Yes</li>
<li>Runtime: No</li>
<li>De-Init: No </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="ac3bb6c78f7251ee5666621309adde0d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3bb6c78f7251ee5666621309adde0d4">&#9670;&nbsp;</a></span>SetPlatformCfg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a> nvsipl::INvSIPLCamera::SetPlatformCfg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnvsipl_1_1PlatformCfg.html">PlatformCfg</a> const *const&#160;</td>
          <td class="paramname"><em>platformConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnvsipl_1_1NvSIPLDeviceBlockQueues.html">NvSIPLDeviceBlockQueues</a> &amp;&#160;</td>
          <td class="paramname"><em>queues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a platform configuration and returns the device block notification queues. </p>
<p>This method sets a <a class="el" href="structnvsipl_1_1PlatformCfg.html">PlatformCfg</a> camera platform configuration and returns the device block notification queues. The configuration specifies all sensors that will be used by this client.</p>
<p>This method must be called before <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#ab8908aaf6991482b0a67ce2684234e6e">SetPipelineCfg()</a>.</p>
<dl class="section pre"><dt>Precondition</dt><dd>None.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">platformConfig</td><td><a class="el" href="structnvsipl_1_1PlatformCfg.html">PlatformCfg</a> The external devices referenced in the platform configuration must be supported by the SIPL Device Block drivers. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">queues</td><td>The queues that will deliver device block notifications.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b" title="Defines the status codes returned by functions in SIPL modules.">SIPLStatus</a> the completion status of the operation.</dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt handler: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: No</li>
<li>Re-entrant: No</li>
<li>Async/Sync: Sync</li>
</ul>
</li>
<li>Required privileges: Yes, with the following conditions:<ul>
<li>Grants: nonroot, allow</li>
<li>Abilities: public_channel</li>
<li>Application needs to have access to the SGIDs that SIPL depends on as mentioned in the NVIDIA DRIVE OS Safety Developer Guide</li>
</ul>
</li>
<li>API group<ul>
<li>Init: Yes</li>
<li>Runtime: No</li>
<li>De-Init: No </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="a21de1ff999eb8962f7a69cbf358a4a3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21de1ff999eb8962f7a69cbf358a4a3d">&#9670;&nbsp;</a></span>SetSensorCharMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a> nvsipl::INvSIPLCamera::SetSensorCharMode </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>expNo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set sensor in characterization mode. </p>
<p>This function re-configures the sensor i.e. changes the sensor static attributes like numActiveExposures, sensorExpRange, sensorGainRange and hence, should be called during sensor initialization time. In order to characterize the sensor exposure number 'n', where n = {1,2,3, ... , N} for N-exposure HDR sensor, the input parameter 'expNo' should be set to 'n'. For a non-HDR sensor, the input parameter 'expNo' should always be set to '1'.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This function must be called after <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#a5ea69c4c93f839ce6b86420b7cdb8ad0">Init()</a> and before <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#ae265de46988e46f2719b0c075e721e19">Start()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The ID of the sensor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">expNo</td><td>Sensor exposure number to be used for characterization.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b" title="Defines the status codes returned by functions in SIPL modules.">SIPLStatus</a> the completion status of the operation.</dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt handler: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: No</li>
<li>Re-entrant: No</li>
<li>Async/Sync: Sync</li>
</ul>
</li>
<li>Required privileges: Yes, with the following conditions:<ul>
<li>Grants: nonroot, allow</li>
<li>Abilities: public_channel</li>
<li>Application needs to have access to the SGIDs that SIPL depends on as mentioned in the NVIDIA DRIVE OS Safety Developer Guide</li>
</ul>
</li>
<li>API group<ul>
<li>Init: Yes</li>
<li>Runtime: No</li>
<li>De-Init: No </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="ae265de46988e46f2719b0c075e721e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae265de46988e46f2719b0c075e721e19">&#9670;&nbsp;</a></span>Start()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a> nvsipl::INvSIPLCamera::Start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Begin streaming from all sensors in the selected platform configuration. </p>
<p>This method starts the streaming from sensors belonging to each device block in the selected platform configuration, and starts the associated image processing pipelines.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This function must be called after <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#aeb039b78b216013784654985346af728">RegisterImages()</a> is called for capture and enabled ISP outputs, <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#aaba89991ad75bef5b9abf95002c5adcf">RegisterAutoControlPlugin()</a> (if ISP output is enabled), and <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#a220e761f59710bb9c290adefa0b57dc9">RegisterNvSciSyncObj()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b" title="Defines the status codes returned by functions in SIPL modules.">SIPLStatus</a> the completion status of the operation.</dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt handler: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: No</li>
<li>Re-entrant: No</li>
<li>Async/Sync: Async</li>
</ul>
</li>
<li>Required privileges: Yes, with the following conditions:<ul>
<li>Grants: nonroot, allow</li>
<li>Abilities: public_channel</li>
<li>Application needs to have access to the SGIDs that SIPL depends on as mentioned in the NVIDIA DRIVE OS Safety Developer Guide</li>
</ul>
</li>
<li>API group<ul>
<li>Init: Yes</li>
<li>Runtime: No</li>
<li>De-Init: No </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="a4abc9d68fe563d07ad612b5c421da801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4abc9d68fe563d07ad612b5c421da801">&#9670;&nbsp;</a></span>Stop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a> nvsipl::INvSIPLCamera::Stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stop streaming from all sensors in the selected platform configuration. </p>
<p>This method stops the streaming from sensors belonging to each device block in the selected platform configuration, and stops the associated image processing pipelines.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This function must be called after <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#ae265de46988e46f2719b0c075e721e19">Start()</a> and before <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#aff3d0798198a31e1a7921c83ff5af3d0">Deinit()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b" title="Defines the status codes returned by functions in SIPL modules.">SIPLStatus</a> the completion status of the operation.</dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt handler: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: No</li>
<li>Re-entrant: No</li>
<li>Async/Sync: Async</li>
</ul>
</li>
<li>Required privileges: Yes, with the following conditions:<ul>
<li>Grants: nonroot, allow</li>
<li>Abilities: public_channel</li>
<li>Application needs to have access to the SGIDs that SIPL depends on as mentioned in the NVIDIA DRIVE OS Safety Developer Guide</li>
</ul>
</li>
<li>API group<ul>
<li>Init: No</li>
<li>Runtime: No</li>
<li>De-Init: Yes </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="a9ba0a26f4e1d3ebe8b105bddfc370480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ba0a26f4e1d3ebe8b105bddfc370480">&#9670;&nbsp;</a></span>ToggleLED()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b">SIPLStatus</a> nvsipl::INvSIPLCamera::ToggleLED </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Control the LED on the associated camera module. </p>
<p>This method tries to enable or disable the LED on the specific module. It is valid only if there is an LED on the camera module and it is controlled by the sensor.</p>
<dl class="section pre"><dt>Precondition</dt><dd>This function should only be called after <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#ae265de46988e46f2719b0c075e721e19">Start()</a> and before <a class="el" href="classnvsipl_1_1INvSIPLCamera.html#a4abc9d68fe563d07ad612b5c421da801">Stop()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The ID of the sensor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enable</td><td>Enable or disable LED.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__NvSIPL.html#gabb402f2b9829b1136cceae5763e6ed3b" title="Defines the status codes returned by functions in SIPL modules.">SIPLStatus</a> the completion status of the operation.</dd></dl>
<p><br  />
 <b>Usage considerations</b></p><ul>
<li>Allowed context for the API call<ul>
<li>Interrupt handler: No</li>
<li>Signal handler: No</li>
<li>Thread-safe: No</li>
<li>Re-entrant: Yes</li>
<li>Async/Sync: Sync</li>
</ul>
</li>
<li>Required privileges: Yes, with the following conditions:<ul>
<li>Grants: nonroot, allow</li>
<li>Abilities: public_channel</li>
<li>Application needs to have access to the SGIDs that SIPL depends on as mentioned in the NVIDIA DRIVE OS Safety Developer Guide</li>
</ul>
</li>
<li>API group<ul>
<li>Init: No</li>
<li>Runtime: Yes</li>
<li>De-Init: No </li>
</ul>
</li>
</ul>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="NvSIPLCamera_8hpp_source.html">NvSIPLCamera.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!--
# Copyright (c) 2022, NVIDIA CORPORATION. All rights reserved.
#
# NVIDIA CORPORATION and its licensors retain all intellectual property
# and proprietary rights in and to this software, related documentation
# and any modifications thereto.  Any use, reproduction, disclosure or
# distribution of this software and related documentation without an express
# license agreement from NVIDIA CORPORATION is strictly prohibited.
-->
  <div id="nav-path" class="navpath">
    <ul>
      <li class="footer footer-left">
        Subject to Change | For test and development only. <br/>
         2022 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
      </li>
      <li class="footer">
        Tue Nov 29 2022 20:35:33 |
        PR-10720-6.0
      </li>
      </li>
     </ul>
  </div>
<script type="text/javascript">if (typeof _satellite != "undefined"){ _satellite.pageBottom();}</script>
</body>
</html>
